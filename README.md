Куда складывать:
- Google Диск Exel Manual/Rust(Patterns/Algorithms)
- Google Диск Exel Manual/Patterns
- GitHub Jekahome/Pattrens

Источники:
- книги ../DesignPatterns_AndriyBuday
- книги ../Design-Patterns.md
- книги ../Разработка интерфейсов.паттерны проектирования.Дженифер Тидвелл
- книги ../Head_First_Паттерны_проектирования_2022_Эрик_Фримен,_Элизабет_Робсон
- код ../Patterns_Others_lang
- код ../Patterns_Rust_PHP_TypeScript

[Rust Design Patterns](https://rust-unofficial.github.io/patterns/)


[Rust Design Patterns rust-unofficial](https://github.com/rust-unofficial/patterns)
[Rust Design Patterns refactoring.guru](https://refactoring.guru/ru/design-patterns/rust)
 

[Реализация конечного автомата (переходы между состояниями)](https://hoverbear.org/blog/rust-state-machine-pattern/)

[шаблон Состояние (+exel example)](https://doc.rust-lang.ru/book/ch17-03-oo-design-patterns.html)

### ООП паттерны
[Rust Design Patterns](https://chercher.tech/rust/observer-design-pattern-rust)
[Паттерны проектирования](http://design-pattern.ru/patterns/)
[Каталог шаблонов архитектуры корпоративных приложений](https://martinfowler.com/eaaCatalog/index.html)


[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

[Что такое анти-паттерны?](https://habr.com/ru/articles/59005/)


### DesignPatternsPHP
[DesignPatternsPHP 1](https://designpatternsphp.readthedocs.io/ru/latest/index.html)
[DesignPatternsPHP github](https://github.com/domnikl/DesignPatternsPHP)
[DesignPatternsPHP 2](https://dron.by/)


[«Паттерны» функционального программирования](https://habr.com/ru/articles/337880/)

### ------------------------------------------------------------------

### Что такое паттерны, зачем и почему они полезны, что дают?

Способ решения часто встречающихся задач. 
Они делают наше программное обеспечение более модульным, удобным в сопровождении и расширяемым. 
Более того, эти шаблоны предоставляют разработчикам общий язык, что делает их отличным инструментом для эффективного общения при решении проблем в группах.



### Подходят ли ООП паттерны для Rust?

Rust - статически типизированный язык системного уровня программирования, с парадигмой функционального и процедурного стиля. Используется не только для системного программирования интрументария но и для прикладных программ пользователю, WEB бэкенд и фронтенд, игр, встроенных систем микроконтроллеров.
В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций. Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.
Парадигмы - это стили написания кода, в Rust есть возможности структурировать код в функциональном стиле используя методы итератора,вектора или собственными силами соблюдая правила:
неизменяемость данных,чистые функции(не имеют побочных эффектов),композиция функций(объединения нескольких функций в одну),функции высшего порядка(принимают другие функции в качестве аргументов или возвращают),отсутвие операций присвоения для сохранения промежуточных результатов вызовов функций.
Так же сможем придерживаться процедурного стиля, компоновать код для повторного использования с применением присвоения для сохранением промежуточных данных между вызовами процедур. 
И это не запрещает нам структурировать код в ООП стиле (нет наследования данных и реализаций, только интерфейсов через super-trait, есть инкапсуляция c помошью mod и есть полиморфизм c помощью trait-object и параметрический полиморфизм дженериков и ограничение трейтами). 
Сдедовательно, только наши цели (предметная область) и ограничения или особенности языка (идиомы), задают каким образом использовать паттерны.  

**Императив**
```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

**Декларативный**
```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```
Помните, что в декларативных программах мы описываем, **что** делать, а не **как** это делать. 
`fold` это функция, которая составляет функции.

Также благодаря `static dispatch` мы можем вынести потенциальные ошибки использования типов на этап компиляции кода.  
Система типов Rust может превратить многие виды проблем программирования в проблемы `static dispatch`. 
Это одно из самых больших преимуществ при выборе функционального языка, и оно имеет решающее значение для многих гарантий времени компиляции Rust.
В Rust параметр универсального типа создает то, что в функциональных языках называется «**ограничением класса типа**».
Это называется **мономорфизацией**, когда разные типы создаются из полиморфного кода.

**Альтернативы**
Если типу требуется «разделенный API» из-за конструкции или частичной инициализации, вместо этого рассмотрите **Builder Pattern**.

Если API между типами не меняется — меняется только поведение — тогда лучше использовать **Strategy Pattern**.


### [Rust patterns](https://rust-unofficial.github.io/patterns/)

**Rust idioms** : рекомендации, которым следует следовать при кодировании. Это согласованные нормы общества. Нарушать их следует только в том случае, если у вас есть для этого веская причина.
[Rust idioms rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)
[Rust idioms rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/index.html)
[Rust idioms rust-unofficial github](https://github.com/Jekahome/RustDesignPatterns/tree/main/src/idioms)

**Anti patterns** : методы решения распространенных проблем при кодировании. Однако, хотя шаблоны проектирования дают нам преимущества, антишаблоны создают больше проблем.

**Design principles** : SOLID, KISS, DRY, YAGNI рекомендации написания кода.

**Design patterns** : методы решения распространенных проблем при кодировании.



**Принципы DDD и слоеной архитектуры, CQRS-ES**



# Rust idioms

...  


# Design principles

### SOLID

Принцип единой ответственности (SRP) : класс должен иметь только одну ответственность, то есть только изменения в одной части спецификации программного обеспечения должны иметь возможность повлиять на спецификацию класса.
Принцип открытости/закрытости (OCP) : «Программные объекты… должны быть открыты для расширения, но закрыты для модификации».
Принцип замены Лискова (LSP) : «Объекты в программе должны быть заменены экземплярами их подтипов без изменения корректности этой программы».
Принцип разделения интерфейсов (ISP) : «Многие клиентские интерфейсы лучше, чем один интерфейс общего назначения».
Принцип инверсии зависимостей (DIP) : нужно «зависеть от абстракций, а не от конкретики».

### DRY (Не повторяйтесь) 

«Каждая часть знаний должна иметь единственное, однозначное и авторитетное представление в системе»

### KISS

большинство систем работают лучше всего, если их сохранять простыми, а не усложнять; следовательно, простота должна быть ключевой целью проектирования, и следует избегать ненужной сложности.

# Design patterns

...

# Anti patterns

...

### CQRS-ES

Разделение команд-запросов (CQS) «Функции не должны вызывать абстрактные побочные эффекты... только команды (процедуры) могут вызывать побочные эффекты». - Бертран Мейер: Объектно-ориентированное создание программного обеспечения

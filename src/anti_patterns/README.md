
# [Anti-patterns](https://rust-unofficial.github.io/patterns/anti_patterns/index.html)

Методы решения распространенных проблем при кодировании.
Однако, хотя шаблоны проектирования дают нам преимущества, анти-шаблоны создают больше проблем.


Антишаблон — это решение «повторяющейся проблемы, которая обычно неэффективна и рискует оказаться крайне контрпродуктивной». Знать, как не решать проблему, так же ценно, как и знать, как ее решить. 
Антишаблоны дают нам отличные контрпримеры для рассмотрения относительно шаблонов проектирования. Антишаблоны не ограничиваются кодом. Например, процесс тоже может быть антишаблоном.

## Клонирование для проверки заимствований (borrow checker)

Если вы используете `.clone()` что-бы обойти правила заимствования Rust, то это анти-паттерн.
В общем, клонирование должно быть осознанным, с полным пониманием последствий. 

```
// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &mut (x.clone());

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!("{}", x);

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;

```

Rust предоставляет типажи `Rc,Arc` для случаев когда нам нужно несколько «владеющих» указателей на одни и те же данные.

Несмотря на то, что `.clone()` указывает на плохой шаблон, иногда можно написать неэффективный код, например, в следующих случаях:

- developer все еще является новым владельцем;

- код не имеет больших ограничений по скорости или памяти (как проекты хакатонов или прототипы);

- выполнить проверку заимствований действительно сложно, и вы предпочитаете оптимизировать читаемость, а не производительность;

Также обязательно всегда запускайте свой проект c `cargo clippy`, который обнаружит некоторые случаи, в которых нет необходимости в `.clone()`

## Использование подавление предупреждений компилятора при сборке

Использование `#![deny(warnings)]` является анти-паттерном, так как ведет к потенциальным ошибкам в будущем.

Иногда новые функции или старые недостатки требуют изменения в том, как что-то делается, поэтому `lints` записываются `warn` на определенный льготный период, прежде чем их переведут на `deny`.

Кроме того, иногда API устаревают, поэтому при их использовании будет выдаваться предупреждение там, где раньше его не было.

**Альтернативы**

Есть два способа решения этой проблемы: во-первых, мы можем отделить настройку сборки от кода, а во-вторых, мы можем явно назвать тесты, которые хотим запретить.

Следующая командная строка будет построена со всеми предупреждениями, установленными на deny:

`RUSTFLAGS="-D warnings" cargo build`

Это может сделать любой отдельный разработчик (или настроить в инструменте CI, таком как Travis, но помните, что это может привести к поломке сборки, если что-то изменится) без необходимости внесения изменений в код.

Альтернативно, мы можем указать нужные нам линты denyв коде. Вот список предупреждений, которые (надеюсь) можно безопасно отклонить (начиная с Rustc 1.48.0):

```
#![deny(bad_style,
       const_err,
       dead_code,
       improper_ctypes,
       non_shorthand_field_patterns,
       no_mangle_generic_items,
       overflowing_literals,
       path_statements,
       patterns_in_fns_without_body,
       private_in_public,
       unconditional_recursion,
       unused,
       unused_allocation,
       unused_comparisons,
       unused_parens,
       while_true)]
```
Кроме того, может быть хорошей идеей запретить следующие разрешенные линты:

```
#![deny(missing_debug_implementations,
       missing_docs,
       trivial_casts,
       trivial_numeric_casts,
       unused_extern_crates,
       unused_import_braces,
       unused_qualifications,
       unused_results)]
```
Некоторые, возможно, также захотят дополнить `missing-copy-implementations` в свой список.

Список линтов в вашей системе `rustc -W help`  

Общий список опций `rustc --help` 

[rust-clippy](https://github.com/Manishearth/rust-clippy) — это набор тестов для улучшения кода Rust

[Коллекция всех клипповых ворсинок](https://rust-lang.github.io/rust-clippy/master)

## Неправильное использование трейта `Deref`

(антишаблон полиморфизма deref)

Неправильно используйте трейт `Deref` для эмуляции наследования между структурами.


**Пример**
Иногда нам нужно эмулировать следующий общий шаблон объектно-ориентированных языков, таких как Java:
```java
class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}

```

Для этого мы можем использовать антишаблон полиморфизма deref:
```rust
use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}

```
В Rust нет наследования структур. Вместо этого мы используем композицию и включаем экземпляр Foo в Bar.

```rust
impl Bar {
    fn m(&self) {
        self.f.m()
    }
}
```

**Недостатки**

Будущие программисты, читающие это в коде, не будут ожидать, что это произойдет.
Это потому, что мы неправильно используем `Deref`. Признак Deref предназначен для реализации пользовательских типов указателей. Цель состоит в том, чтобы он принимал указатель на T, а не выполнял преобразование между различными типами.

Это еще и потому, что механизм здесь совершенно неявный.

Наконец, этот шаблон поддерживает только одиночное наследование и не имеет понятия об интерфейсах, конфиденциальности на основе классов или других функциях, связанных с наследованием. Таким образом, это дает опыт, который будет слегка удивить программистов, привыкших к наследованию Java и т. д.

**Обсуждение**

Нет ни одной хорошей альтернативы. В зависимости от конкретных обстоятельств может быть лучше повторно реализовать использование признаков или написать фасадные методы для ручной диспетчирезации Foo. 

## [Золотой молоток (Golden hammer)](https://habr.com/ru/articles/59005/)

Золотой молоток — уверенность в полной универсальности любого решения. На практике, это — применение одного решения (чаще всего какого-либо одного паттерна проектирования) для всех возможных и невозможных задач. Попытка решить все задачи единственным методом, который знаком. Для каждой задачи имеется не одно, а несколько, красивых и оптимальных решений — именно к поиску таких решений и сводится эффективная разработка. 

## Мягкое кодирование (Soft code)/Жёсткое кодирование (Hard code)

Перед началом решения определённой задачи следует определить, что должно быть настариваемым, а что является постоянным для различных систем или может быть настроено автоматически.
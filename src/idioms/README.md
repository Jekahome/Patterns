# Идиомы

Идиомы — это широко используемые стили, рекомендации и шаблоны, в значительной степени согласованные сообществом. Написание идиоматического кода позволяет другим разработчикам лучше понимать, что происходит.

1. Type safety  

    1.1 Newtype

    1.2 Typestates
2. Mem replace
3. Bound impl
4. Generic in type out
5. Exhaustivity
6. Sealing
 
[Идиомы rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/concat-format.html)

1. Используйте в качестве аргументов `&Type` заимствованные типы  
2. Объединение строк с помощью `format!`
3. Конструктор с помощью ф-ции `new` и конструктор по умолчанию `Default`
4. Трейт `Default`
5. Коллекции — это умные указатели (используйте `Deref` для своих коллекций)
6. Финализация в деструкторах `Drop`
7. `mem::{take(_), replace(_)}`
8. Динамическая диспетчеризация на стеке
9. Идиомы при написании интерфейса внешних функций (`FFI`)
10. Перебор `Option` (`Option impl IntoIterator`)
11. Передача переменных в замыкание (используйте перепривязку переменных в отдельной области)
12. Конфиденциальность ради расширяемости (`non_exhaustive`)
13. Простая инициализация документа (избавится от грамоздкой документации)
14. Временная изменчивость (заменить мутабельную переменню на не мутабельную путем переопределения переменной)
15. Возвращать использованный аргумент при ошибке



# Идиомы с [rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)

## 1. Type safety

"Безопасный тип" - это способ ограничить функционал прогпаммы конкретным типом, 
что бы компилятор фильтровал некорректные способы использования. 
Покрывая код "безопасными типами" мы увеличиваем шансы корректного использования.

### 1.1 Newtype

Предотвращает недопустимое использование данных.
Завернув обший тип в свою оболочку мы получаем свой собственный тип данных,
который неполучится спутать с его внутренным типом и подставить в неверное место,
так же вы можете обеспечить требуемые инварианты для значений типа, ограничив или расширив их.
Также newtype ближе к предметной области и следовательно лугче документировать и понять его применение.
Newtype не несет дополнительных накладных расходов во время выполнения (абстракция с нулевой стоимостью),
но для полноценного использования newtype требуется реализовать трейты (`Clone/Copy,From/Into,AsRef​​/AsMut...`)

### 1.2 Type states

Подход "состояние типа" позволяет контролировать последовательность смены состояний при 
выполнении программы еще на этапе компиляции. Мы можем описать поведение типа, 
какие состояния он может принимать и в какой последовательности.

## 2. Mem replace

Поскольку Rust подразумевает семантику перемещения по умолчанию и довольно строгие правила заимствования, часто возникают ситуации (особенно с большими structs и enums), когда изменение значения на месте или замена значений не могут быть разрешены средством проверки заимствований, что довольно сбивает с толку и приводит к к созданию ненужных клонов (что приводит к избыточным затратам на производительность).

## 3. Bound impl

Описывайте bond сигнатурой не данные, а поведение т.е. методы.
Размещение границ признаков на impl блоках, методах и функциях, а не на типах, уменьшает загрязнение границ признаков, уменьшает связанность частей кода и делает общий код более чистым, простым и эргономичным.
Структуры данных не должны дублировать производные границы признаков.
Вы должны попытаться максимально поднять границы признаков (особенно в коде библиотеки), поскольку это расширяет возможности использования типа.

## 4. Generic in type out

Абстрагируйтесь от конкретного типа входных данных строки, что бы увеличить гибкость API, принимая как можно больше различных типов. Типажи в помощь `AsRef,Borrow,Into,Cow`
Обратной стороной этой идиомы является то, что компилятор генерирует больше кода из-за мономорфизации, что потенциально приводит к раздуванию кода. Каноническое решение этой проблемы — исключить внутренний метод, содержащий весь код за вычетом универсальных преобразований, и оставить внешний метод в качестве оболочки.

## 5. Exhaustivity

Проверка на полноту вариантов.
Расширяя кодовую базу уже имеющихся перечислений и структур, есть шанс не учесть новые поля в коде, что может привести к ошибке во время выполнения. Для того чтобы отловить эту ошибку на этапе компиляции следует придерживаться следующих рекомендаций. Использовать полный список вариантов перечислений и пользоваться полями созданной струтурой,а не отдельными ее полями.

## 6. Sealing

Запечатывание в программировании обычно означает, что некоторые API (в основном общедоступные) не могут быть унаследованы, расширены или реализованы за пределами места их определения.
Основная цель запечатывания признака — это перспективность API. Так как мы уверены в том что только мы используем все имплементации запечатанного трейта то мы можем его менять.
Sealed трейт — общедоступный трейт, который не может быть реализован вне места его определения ( модуля или крейта , в зависимости от видимости этого трейта).

 
# Идиомы с [rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/concat-format.html)

## 3. Конструктор с помощью ф-ции `new` и конструктор по умолчанию `Default`

```
/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::new(42);
/// assert_eq!(42, s.value());
/// ```
pub struct Second {
    value: u64
}

impl Second {
    // Constructs a new instance of [`Second`].
    // Note this is an associated function - no self.
    pub fn new(value: u64) -> Self {
        Self { value }
    }

    /// Returns the value in seconds.
    pub fn value(&self) -> u64 {
        self.value
    }
}

```

**Конструктор по умолчанию**

```
/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
// или #[derive(Default)]
pub struct Second {
    value: u64
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&self) -> u64 {
        self.value
    }
}

impl Default for Second {
    fn default() -> Self {
        Self { value: 0 }
    }
}

```

## 8. Динамическая диспетчеризация на стеке

```
use std::io;
use std::fs;

// Каждая переменная содержит значения только одного типа. 
// В нашем примере stdin имеет тип Stdin, file имеет тип File и readable имеет тип &mut dyn Read
let (mut stdin_read, mut file_read);

let readable: &mut dyn io::Read = if arg == "-" {
    stdin_read = io::stdin();
    &mut stdin_read
} else {
    file_read = fs::File::open(arg)?;
    &mut file_read
};
```

**Преимущества**

Нам не нужно ничего размещать в куче. 
Нам также не нужно инициализировать что-то, что мы не будем использовать позже, и нам не  нужно мономорфизировать весь следующий код для работы с обоими File или Stdin.

Версия аналогичного кода но с выделением памяти в куче:

```
let readable: Box<dyn io::Read> = if arg == "-" {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
```

## 11. Передача переменных в замыкание 

(используйте перепривязку переменных в отдельной области)

По умолчанию замыкания захватывают свое окружение путем заимствования. 
Или вы можете использовать move-closure для перемещения всей среды. 
Однако часто требуется переместить в замыкание только некоторые переменные, передать ему копию некоторых данных, передать их по ссылке или выполнить какое-либо другое преобразование.

Для этого используйте перепривязку переменных в отдельной области.

```
use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

// Хорошо
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};

// Плохо
let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};

```
**Преимущества**

Скопированные данные группируются вместе с определением замыкания, поэтому их назначение становится более ясным, и они будут немедленно удалены, даже если они не будут использованы замыканием.

Замыкание использует те же имена переменных, что и окружающий код, независимо от того, копируются или перемещаются данные.

## 14. Временная мутабельность 

(заменить мутабельную переменню на не мутабельную путем переопределения переменной)

Часто необходимо подготовить и обработать некоторые данные, но после этого данные только проверяются и никогда не изменяются. Намерение можно сделать явным, переопределив изменяемую переменную как неизменяемую.

Это можно сделать либо путем обработки данных внутри вложенного блока, либо путем переопределения переменной.

Скажем, вектор перед использованием необходимо отсортировать.

**Использование вложенного блока:**
```
let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.
```

**Использование перепривязки переменных:**
```
let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.
```

## 15. Возвращать использованный аргумент при ошибке

Если функция потребляет (перемещает) аргумент, верните этот аргумент обратно внутри ошибки.
Что бы не засталять пользователей клонировать эти данные в случае необходимости использовать как-то повторно эти данные.

```
pub struct SendError(String);

pub fn send(value: String) -> Result<(), SendError> {
    println!("using {value} in a meaningful way");
    // Simulate non-deterministic fallible action.
    use std::time::SystemTime;
    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();
    if period.subsec_nanos() % 2 == 1 {
        Ok(())
    } else {
        Err(SendError(value))
    }
}
```
### Что такое паттерны, зачем и почему?

Способ решения часто встречающихся задач. 
Они делают наше программное обеспечение более модульным, удобным в сопровождении и расширяемым. 
Более того, эти шаблоны предоставляют разработчикам общий язык, что делает их отличным инструментом для эффективного общения при решении проблем в группах.


### Подходят ли ООП паттерны для Rust?

Rust - статически типизированный язык системного уровня программирования, с парадигмой функционального и процедурного стиля. Используется не только для системного программирования интрументария но и для прикладных программ пользователю, WEB бэкенд и фронтенд, игр, встроенных систем микроконтроллеров.

В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций.
Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.
Парадигмы - это стили написания кода, в Rust есть возможности структурировать код в функциональном стиле используя методы итератора,вектора или собственными силами соблюдая правила:
неизменяемость данных,чистые функции(не имеют побочных эффектов),композиция функций(объединения нескольких функций в одну),функции высшего порядка(принимают другие функции в качестве аргументов или возвращают),отсутвие операций присвоения для сохранения промежуточных результатов вызовов функций.

Так же сможем придерживаться процедурного стиля, компоновать код для повторного использования с применением присвоения для сохранением промежуточных данных между вызовами процедур. 
И это не запрещает нам структурировать код в ООП стиле (нет наследования данных и реализаций, только интерфейсов через super-trait, есть инкапсуляция c помошью mod и есть полиморфизм c помощью trait-object и параметрический полиморфизм дженериков и ограничение трейтами). 
Сдедовательно, только наши цели (предметная область) и ограничения или особенности языка (идиомы), задают каким образом использовать паттерны.  

**Императив**
```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

**Декларативный**
```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```
Помните, что в декларативных программах мы описываем, **ЧТО** делать, а не **КАК** это делать. 

`fold` это функция, которая составляет функции.

Также благодаря `static dispatch` мы можем вынести потенциальные ошибки использования типов на этап компиляции кода.  
Система типов Rust может превратить многие виды проблем программирования в проблемы `static dispatch`. 
Это одно из самых больших преимуществ при выборе функционального языка, и оно имеет решающее значение для многих гарантий времени компиляции Rust.
В Rust параметр универсального типа создает то, что в функциональных языках называется «**ограничением класса типа**».
Это называется **мономорфизацией**, когда разные типы создаются из полиморфного кода.

**Альтернативы**

Если типу требуется «разделенный API» из-за конструкции или частичной инициализации, вместо этого рассмотрите **Builder Pattern**.

Если API между типами не меняется — меняется только поведение — тогда лучше использовать **Strategy Pattern**.

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Rust%20idioms.png "Rust idioms")

Рекомендации, которым следует следовать при кодировании. Это согласованные нормы общества. Нарушать их следует только в том случае, если у вас есть для этого веская причина.

[Rust idioms rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)

[Rust idioms rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/index.html)

[Rust idioms rust-unofficial github](https://github.com/Jekahome/RustDesignPatterns/tree/main/src/idioms)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Anti%20patterns.png "Anti patterns")

Методы решения распространенных проблем при кодировании. Однако, хотя шаблоны проектирования дают нам преимущества, антишаблоны создают больше проблем.


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20principles.png "Design principles")

### Design principles: SOLID

Принцип единой ответственности (SRP): класс должен иметь только одну ответственность, то есть только изменения в одной части спецификации программного обеспечения должны иметь возможность повлиять на спецификацию класса.

Принцип открытости/закрытости (OCP): «Программные объекты… должны быть открыты для расширения, но закрыты для модификации».

Принцип замены Лискова (LSP): «Объекты в программе должны быть заменены экземплярами их подтипов без изменения корректности этой программы».

Принцип разделения интерфейсов (ISP): «Многие клиентские интерфейсы лучше, чем один интерфейс общего назначения».

Принцип инверсии зависимостей (DIP): нужно «зависеть от абстракций, а не от конкретики».

### Design principles: KISS

Большинство систем работают лучше всего, если их сохранять простыми, а не усложнять; следовательно, простота должна быть ключевой целью проектирования, и следует избегать ненужной сложности.
Простота кода – превыше всего, потому что простой код – наиболее понятный.
Если вы используете паттерн проектирования там, где нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код. 
Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
Моя интерпритация KISS - соблюдать необходимые рекомендации разработки проекта чтобы, в момент когда проект достигнет немалых масштабов и потребуется вносить изменения, то разработчик мог это сделать малыми силами. Для этого, помимо использования общеизвестных паттернов и идиом технологии/языка если они уместны, должна быть в наличии документация, тесты, необходимые комментарии, ссылки на источники, само собой разумеется SOLID, содержательные имена. К тому же, архитектура приложения должна предусматривать внесение вероятных изменений.  

[KISS — принцип проектирования, содержащий все остальные принципы проектирования](https://habr.com/ru/articles/249639/)

### Design principles: DRY

"**Не повторяйте себя.**"

Короче говоря, всякий раз, когда вы ловите себя на том, что пишете один и тот же код дважды, у вас есть возможность стать более эффективным.
Следование этому принципу означает, что ваша цель — сократить количество повторяющихся шаблонов и дублирования кода и логики в пользу модульного кода, на который можно ссылаться т.е. использовать повторно.

В книге «Программист-прагматик» мы можем увидеть такое определение DRY:
«Каждая часть знаний должна иметь единственное, однозначное и авторитетное представление в системе»

Это означает, что у вас не должно быть дублированного кода. Легче поддерживать код, который находится только в одном месте, потому что если вам нужно что-то изменить в коде, вам просто нужно изменить это в одном месте. Кроме того, если у вас есть один и тот же код в двух или более местах, вероятность того, что этот код со временем станет другим, высока, и когда это произойдет, это станет простым способом внести ошибки в вашу систему. Дублированный код также делает код более сложным и неоправданно большим.

### Design principles: YAGNI 

"**Тебе это не понадобится**"

Это означает, что вам не следует реализовывать функциональность только потому, что вы думаете, что она вам когда-нибудь понадобится, а реализовывать ее только тогда, когда она вам действительно понадобится. Поступая так, вы избежите траты времени на реализации, которые даже не были необходимы и, возможно, никогда не будут использоваться.

[Design principles](https://rust-unofficial.github.io/patterns/additional_resources/design-principles.html)

[dry-kiss-yagni-principles](https://henriquesd.medium.com/dry-kiss-yagni-principles-1ce09d9c601f)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20patterns.png "Design patterns")

Методы решения распространенных проблем при кодировании.

### **Порождающие паттерны**

Паттерны которые создают новые объекты, или позволяют получить доступ к уже существующим. То есть те шаблоны, по которым можно создать новый автомобиль и как это лучше сделать.

#### Abstract factory	

Его основное назначение - предоставить интерфейс для создания семейства взаимосвязанных объектов, не специфицируя их классы.
Используется в тех случаях, когда необходимо изменять поведение системы,
варьируя создаваемыми объектами, при этом сохраняя интерфейсы. Он позволяет создавать группы взаимосвязанных объектов,
реализующих общее поведение. 
Например, в зависимости от конкретных условий

#### Factory method	

Для полиморфизма
классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя.

Достоинства
позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а оперируя лишь общим интерфейсом;
позволяет установить связь между параллельными иерархиями классов.

Недостатки
необходимость создавать наследника Creator для каждого нового типа продукта "

#### Prototype	

Он используется для задания вида создаваемых объектов на основе объекта прототипа, от которого происходит передача внутреннего состояния.

#### Singelton	

Паттерн Singleton (Одиночка) применяется в том случае, когда какой-либо класс может иметь только один экземпляр (или не иметь ни одного) и легко доступен из глобальной видимости.

#### Builder	

Паттерн абстрактная фабрика во многом схож со строителем, так как так же позволяет конструировать сложные объекты, с тем лишь отличием, что абстрактная фабрика заточена на создании семейств объектов (простых и сложных), в то время как строитель делает акцент на пошаговом создании объекта.

#### Object Pool Pattern	

Этот тип шаблона проектирования предоставляет метод повторного использования инициализированных объектов вместо создания новых 
Это позволяет вызвать определенный объект из пула для использования в течение определенного периода времени, 
а затем вернуть его обратно в пул после выполнения задания. 
Во время отсутствия этого объекта никакие другие компоненты не могут использовать его, пока он не будет возвращен обратно в пул.


### **Структурирующие паттерны**

Данные паттерны помогают внести порядок и научить разные объекты более правильно взаимодействовать друг с другом.

#### Adapter/Wrapper	

Обернуть работу с неподходящим API к своему интерфейсу
Он используется для преобразования одного интерфейса в другой, необходимый клиенту. Адаптер обеспечивает совместимость несовместимых интерфейсов, реализуя прослойку.

#### Composite,Facade 	

Спраятать за удобным интерфейсом сложное управление и последовательность действий
Он используется для компоновки объектов в древовидные структуры для представления иерархий,позволяя одинаково трактовать индивидуальные и составные объекты."

#### DataMaper	

Посредник между постоянным хранилищем и данными в памяти( массив)
Цель паттерна в том,чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных.
В отличии от ActiveRecord где полностью отображается структура реаляционной базы на свойства классов
В связке с паттреном Repository который представляет слой над DataMaper получаем независимую друг от друга систему общения бизнес-логики с данными

Персистентность (т.е. минимизация подверженности изменениям ) архитектурного слоя поддрживает Repository за счет того что он берет на себя все изменения/новые требования бизнес-правил
 и в итоге обьекты DataMapers остаются неизменны

#### ActiveRecord	
Схема Active Record — это подход к доступу к данным в базе данных. Таблица базы данных или представление обёрнуты в классы. Таким образом, объектный экземпляр привязан к единственной строке в таблице. После создания объекта новая строка будет добавляться к таблице на сохранение. Любой загруженный объект получает свою информацию от базы данных. Когда объект обновлён, соответствующая строка в таблице также будет обновлена. Класс обёртки реализует методы средства доступа или свойства для каждого столбца в таблице или представлении.
Нарушает принцип единственной ответственности (SRP) или нет ?

#### Decorator

Декоратор"	"класс который будет работать (оборачивать ) с данными выбираем сами,гибкий механизм комбинирования объектов во время выполнения программы с целью расширения функциональности.
 Он используется для динамического расширения функциональности объекта. Является гибкой альтернативой наследованию.

Сущность работы паттерна декоратор заключается в ""оборачивании"" готового объекта новым функционалом, при этом весь оригинальный интерфейс объекта остается доступным (декоратор переадресует все запросы объекту). Смысл заключается в том, чтобы можно было безболезненно комбинировать различные декораторы в произвольном порядке, навешивая их на различные объекты. В некотором роде, это похоже на технологию traits, за исключением того, что декораторы динамически навешиваются на объект, а traits статически на класс.

Мост вы отделяете абстракцию от реализации, оборачивая объект, реализованный с помощью класса, который не обязательно имеет один и тот же интерфейс объекта.

Декоратор изменяет существующее поведение, обертывая реализованный объект классом, который наследует тот же интерфейс, что и реализованный объект, поэтому он обязательно имеет то же поведение.

#### Dependency injection DI

Для реализации слабосвязанной архитектуры. 
Для выноса из класса неявных зависимостей тремя способами(путем явной зависимости через конструктор,метод,интерфейс) для явной зависимости что бы была возможность подменить обьекты при тестировании.
Объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму
Чтобы получить более тестируемый, сопровождаемый и расширяемый код.
Реализуется через передачу обьекта в конструктор,метод,интерфейс

Внедрение зависимости позволяет переложить часть ответственности за какой-то функционал на другие объекты. Например если нам требуется нанять новый персонал, то мы можем не создавать свой отдел кадров, а внедрить зависимость от компании по подбору персонала, которая свою очередь по первому нашему требованию «нам нужен человек», будет либо сама работать как отдел кадров, либо же найдет другую компанию (при помощи «локатора служб»), которая предоставит данные услуги.
«Внедрение зависимости» позволяет перекладывать и взаимозаменять отдельные части компании без потери общей функциональности.

#### Bridge

Мост - Он используется для отделения абстракции от ее реализации так, чтобы то и другое можно было изменять независимо.
Когда абстракция много на себя берет , можно разделить ее на части и реализовывать наследование через композицию или агрегацию

Используйте мост, когда:

Хотите избежать постоянной привязки реализации к абстракции (например, когда реализацию необходимо выбирать во время выполнения).
Реализация и абстракция могут (или будут) дополняться через наследование
Изменение на абстракции или реализации не должны сказываться на клиенте
Количество классов начинает стремительно расти, не принося при этом реальной пользы
Вы хотите разделить одну реализации между разными абстракциями
Хотите повысить степень расширяемости
Хотите скрыть детали реализации от клиента
Родственным паттерном для моста является паттерн адаптер, который объединяет связанные части системы и предоставляет простой интерфейс. Правда мост, в отличие от адаптера, внедряется на этапе проектирования, а не на готовых рабочих системах.

[Bridge](http://dron.by/post/pattern-proektirovaniya-bridge-most-na-php.html)


#### Fasade	

Один класс, представляющий всю подсистему.

#### Proxy	

Объект, представляющий другой объект

#### Private Class Data	

Ограниченный доступ к средствам доступа / мутаторам.

#### Flyweight	

Детализированный экземпляр, используемый для эффективного совместного использования.

#### Service Locator	

Для реализации слабосвязанной архитектуры, чтобы получить хорошо тестируемый, сопровождаемый и расширяемый код. Паттерн Инъекция зависимостей (DI) и паттерн Локатор Служб — это реализация паттерна Инверсия управления (Inversion of Control, IoC)
Анти-паттерн так как нарушает принцип SOLID инверсии зависимости т.е. он избавляет другие классы от этого но сам зависим от конкретных классов.
В случае изменения данных зависимостей мы рискуем сломать функционал классов, которые их используют, вследствие чего затрудняется поддержка системы.

#### Row Data Gateway (DataMaper) 

Предоставляет вам объекты, которые выглядят точно так же, как записи в вашей структуре записей, но доступны с помощью обычных механизмов вашего языка программирования. Все детали доступа к источникам данных скрыты за этим интерфейсом.

### **Паттерны поведения**

Эта группа паттернов позволяет структурировать подходы к обработке поведения и взаимодействия объектов. Проще говоря, как должны проходить процессы в которых существует несколько вариантов протекания событий.

#### Command (Команда)	

Суть паттерна в том, чтобы отделить инициатора и получателя команды.Когда логических операторов (if, switch) становится слишком много, а полиморфизм не в силах помочь.

#### Command + Composite	

Компоновка команд в блоки

#### Command + Composite + Chain Of Responsibilities

Компоновка команд в блоки и делегирование другим командам

#### Observer (схож с Mediator)	

Наблюдатель за состоянием и уведомление подписчиков, реализует databinding

В основе шаблона Observer лежит принцип отсоединения клиентских элементов
(наблюдателей) от центрального класса (субъекта). Наблюдатели должны быть проинформированы,
когда происходят события, о которых знает субъект. В то же время
мы не хотим , чтобы у субъекта бьла жестко закодированная связь с его классами-наблюдателями.                                                                                                         

Для реализации публикации/подписки на поведение объекта, всякий раз, когда объект «Subject»
меняет свое состояние, прикрепленные объекты «Observers» будут уведомлены.
Паттерн используется, чтобы сократить количество связанных напрямую объектов
и вместо этого использует слабую связь (loose coupling).


#### Strategy	

Изменить поведение Альтернатива наследования Устраняет дублирование кода

Паттерн Стратегия, согласно "банде четырех", включает в себя следующие классы:
Абстрактная стратегия (есть у вас), Конкретные стратегии (есть у вас), Клиент (есть), Контекст - нет.
Одно из преимуществ использования Стратегии заключается в том, что мы можем избавиться от ветвления,
Достигается это за счет того, что клиент "знает",
какой алгоритм он хочет использовать и передает объект алгоритма в конструктор класса - контекста. Согласно Singl responsibility разделяем классы на подклассы

#### Delegation	 

Объект, вместо того чтобы выполнять одну из своих поставленных задач, поручает её связанному вспомогательному объекту.

#### Interpreter	

С помощью классов создать свой язык для гибкости и простоты использования пользователем


#### Iterator	

Возможность использовать перебор обьекта как массив

Используется в составных объектах. Предоставляет доступ к своим внутренним полям не раскрывая их структуру.

Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой. Это может быть ограничение доступа, сортировка или любая другая операция над множеством объектов.

#### Mediator	

Центр упраляния классами связанных друг с другом снижая их связанность и не надо вызывать друг друга напрямую

Этот паттерн позволяет снизить связность множества компонентов, работающих совместно.
Объектам больше нет нужды вызывать друг друга напрямую. Это хорошая альтернатива Наблюдателю,
если у вас есть “центр интеллекта” вроде контроллера (но не в смысле MVC)
Все компоненты (называемые «Коллеги») объединяются в интерфейс MediatorInterface
Подписчики или объединенные компоненты делегируют управление медиатору

#### State	

В зависимости от состояния изменяется поведение

Состояние
   Инкапсулирует изменение поведения одних и тех же методов в зависимости от состояния объекта.
   Этот паттерн поможет изящным способом изменить поведение объекта во время выполнения
   не прибегая к большим монолитным условным операторам.
   Присутствует четкая последовательность состояний управляемая через контекст

#### Visitor	

Над каждым объектом некоторой структуры выполняется одна или более операций. Нужно определить новую операцию, не изменяя классы объектов.

#### Specification	 

Строит правила на соответствие которых проверяются объекты

Спецификация (Specification)
   Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. 
   Композитный класс спецификация имеет один метод, называемый isSatisfiedBy, 
   который возвращает истину или ложь в зависимости от того, удовлетворяет ли данный объект спецификации.

#### Memento (Хранитель)	

Хранитель Он обеспечивает возможность восстановления объекта до его предыдущего состояния
Хранить и восстанавливать снимок состояния объекта

#### Chain Of Responsibilities 

(цепочка обязанностей) делегировать управление другим классом в нужном случае 

По сути это набор обработчиков, которые по очереди получают запрос, а затем решают обрабатывать его или нет. 
Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то паттерн сам решает передавать его дальше или нет.
middleware

#### Template method	

Шаблонный Метод  Изолирует алгоритм/логику в классы наследники переопределяя родителя 
Устраняет дублирование кода,
Задает скелет алгоритма в методе где вызываются абстрактные методы субклассов

Идея состоит в том, чтобы позволить наследникам абстрактного
шаблона переопределить поведение алгоритмов родителя.
  
Это простой способ изолировать логику в конкретные классы и уменьшить копипаст,
поэтому вы повсеместно встретите его в том или ином виде.

#### Command invoker	 

Command и receiver исполнитель назначение команды и выполнение ее исполнителем


### Шаблоны баз данных

Шаблоны баз данных, сохранять и извлекать данные из баз данных и устанавливать соответствие между объектами базы данных и приложения.

#### Data Mapper 	

Преобразователь Данных — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже загружено и используется для логической обработки). Цель паттерна в том, чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных. Слой состоит из одного или более mapper-а (или объектов доступа к данным), отвечающих за передачу данных. Реализации mapper-ов различаются по назначению. Общие mapper-ы могут обрабатывать всевозоможные типы сущностей доменов, а выделенные mapper-ы будет обрабатывать один или несколько конкретных типов.

#### Identity Map	

Обеспечивает однократную загрузку объекта, сохраняя данные об объекте в карте соответствия. При обращении к объектам, ищет их в карте соответсвия.
Паттерн Identity Map (Карта присутствия / Карта соответствия) хранит записи о всех объектах, которые были считаны из БД за время выполнения одного действия. Когда происходит обращение к объекту, проверяется карта соответствия (присутствия), чтобы узнать, загружен ли объект.

####  Lazy Load 

Загрузка данных по мере необходимости


[Rust patterns](https://rust-unofficial.github.io/patterns/)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

## Принципы DDD 

...

## Слоеная архитектура 

...
 

### CQRS-ES

Разделение команд-запросов (CQS) «Функции не должны вызывать абстрактные побочные эффекты... только команды (процедуры) могут вызывать побочные эффекты». - Бертран Мейер: Объектно-ориентированное создание программного обеспечения

CQRS — это стиль архитектуры, в котором операции чтения отделены от операций записи. Использовал с паттерном command
 Подход сформулировал Грег Янг на основе принципа CQS, предложенного Бертраном Мейером. 
Чаще всего (но не всегда) CQRS реализуется в ограниченных контекстах (bounded context) приложений, проектируемых на основе DDD.
 Одна из естественных причин развития CQRS — не симметричное распределение нагрузки и сложности бизнес-логики на read и write — подсистемы Большинство бизнес-правил и сложных проверок находится во write — подсистеме. 
 
--------------

Куда складывать:
- Google Диск Exel Manual/Rust(Patterns/Algorithms)
- Google Диск Exel Manual/Patterns
- GitHub Jekahome/Pattrens

Источники:
- книги ../DesignPatterns_AndriyBuday
- книги ../Design-Patterns.md
- книги ../Разработка интерфейсов.паттерны проектирования.Дженифер Тидвелл
- книги ../Head_First_Паттерны_проектирования_2022_Эрик_Фримен,_Элизабет_Робсон
- код ../Patterns_Others_lang
- код ../Patterns_Rust_PHP_TypeScript

[Rust Design Patterns](https://rust-unofficial.github.io/patterns/)


[Rust Design Patterns rust-unofficial](https://github.com/rust-unofficial/patterns)
[Rust Design Patterns refactoring.guru](https://refactoring.guru/ru/design-patterns/rust)
 

[Реализация конечного автомата (переходы между состояниями)](https://hoverbear.org/blog/rust-state-machine-pattern/)

[шаблон Состояние (+exel example)](https://doc.rust-lang.ru/book/ch17-03-oo-design-patterns.html)

### ООП паттерны
[Rust Design Patterns](https://chercher.tech/rust/observer-design-pattern-rust)
[Паттерны проектирования](http://design-pattern.ru/patterns/)
[Каталог шаблонов архитектуры корпоративных приложений](https://martinfowler.com/eaaCatalog/index.html)


[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

[Что такое анти-паттерны?](https://habr.com/ru/articles/59005/)


### DesignPatternsPHP
[DesignPatternsPHP 1](https://designpatternsphp.readthedocs.io/ru/latest/index.html)
[DesignPatternsPHP github](https://github.com/domnikl/DesignPatternsPHP)
[DesignPatternsPHP 2](https://dron.by/)


[«Паттерны» функционального программирования](https://habr.com/ru/articles/337880/)

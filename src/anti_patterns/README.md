
# [Anti-patterns](https://rust-unofficial.github.io/patterns/anti_patterns/index.html)

Методы решения распространенных проблем при кодировании.
Однако, хотя шаблоны проектирования дают нам преимущества, анти-шаблоны создают больше проблем.


Антишаблон — это решение «повторяющейся проблемы, которая обычно неэффективна и рискует оказаться крайне контрпродуктивной». Знать, как не решать проблему, так же ценно, как и знать, как ее решить. 
Антишаблоны дают нам отличные контрпримеры для рассмотрения относительно шаблонов проектирования. Антишаблоны не ограничиваются кодом. Например, процесс тоже может быть антишаблоном.

Антипаттерн может быть результатом того, что менеджер или разработчик не знает ничего лучшего, не имеет достаточных знаний или опыта в решении определенного типа проблем или применил совершенно хороший шаблон в неправильном контексте.
 
## Клонирование для проверки заимствований (borrow checker)

Если вы используете `.clone()` что-бы обойти правила заимствования Rust, то это анти-паттерн.
В общем, клонирование должно быть осознанным, с полным пониманием последствий. 

```
// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &mut (x.clone());

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!("{}", x);

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;

```

Rust предоставляет типажи `Rc,Arc` для случаев когда нам нужно несколько «владеющих» указателей на одни и те же данные.

Несмотря на то, что `.clone()` указывает на плохой шаблон, иногда можно написать неэффективный код, например, в следующих случаях:

- developer все еще является новым владельцем;

- код не имеет больших ограничений по скорости или памяти (как проекты хакатонов или прототипы);

- выполнить проверку заимствований действительно сложно, и вы предпочитаете оптимизировать читаемость, а не производительность;

Также обязательно всегда запускайте свой проект c `cargo clippy`, который обнаружит некоторые случаи, в которых нет необходимости в `.clone()`

## Использование подавление предупреждений компилятора при сборке

Использование `#![deny(warnings)]` является анти-паттерном, так как ведет к потенциальным ошибкам в будущем.

Иногда новые функции или старые недостатки требуют изменения в том, как что-то делается, поэтому `lints` записываются `warn` на определенный льготный период, прежде чем их переведут на `deny`.

Кроме того, иногда API устаревают, поэтому при их использовании будет выдаваться предупреждение там, где раньше его не было.

**Альтернативы**

Есть два способа решения этой проблемы: во-первых, мы можем отделить настройку сборки от кода, а во-вторых, мы можем явно назвать тесты, которые хотим запретить.

Следующая командная строка будет построена со всеми предупреждениями, установленными на deny:

`RUSTFLAGS="-D warnings" cargo build`

Это может сделать любой отдельный разработчик (или настроить в инструменте CI, таком как Travis, но помните, что это может привести к поломке сборки, если что-то изменится) без необходимости внесения изменений в код.

Альтернативно, мы можем указать нужные нам линты denyв коде. Вот список предупреждений, которые (надеюсь) можно безопасно отклонить (начиная с Rustc 1.48.0):

```
#![deny(bad_style,
       const_err,
       dead_code,
       improper_ctypes,
       non_shorthand_field_patterns,
       no_mangle_generic_items,
       overflowing_literals,
       path_statements,
       patterns_in_fns_without_body,
       private_in_public,
       unconditional_recursion,
       unused,
       unused_allocation,
       unused_comparisons,
       unused_parens,
       while_true)]
```
Кроме того, может быть хорошей идеей запретить следующие разрешенные линты:

```
#![deny(missing_debug_implementations,
       missing_docs,
       trivial_casts,
       trivial_numeric_casts,
       unused_extern_crates,
       unused_import_braces,
       unused_qualifications,
       unused_results)]
```
Некоторые, возможно, также захотят дополнить `missing-copy-implementations` в свой список.

Список линтов в вашей системе `rustc -W help`  

Общий список опций `rustc --help` 

[rust-clippy](https://github.com/Manishearth/rust-clippy) — это набор тестов для улучшения кода Rust

[Коллекция всех клипповых ворсинок](https://rust-lang.github.io/rust-clippy/master)

## Неправильное использование трейта `Deref`

(антишаблон полиморфизма deref)

Неправильно используйте трейт `Deref` для эмуляции наследования между структурами.


**Пример**
Иногда нам нужно эмулировать следующий общий шаблон объектно-ориентированных языков, таких как Java:
```java
class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}

```

Для этого мы можем использовать антишаблон полиморфизма deref:
```rust
use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}

```
В Rust нет наследования структур. Вместо этого мы используем композицию и включаем экземпляр Foo в Bar.

```rust
impl Bar {
    fn m(&self) {
        self.f.m()
    }
}
```

**Недостатки**

Будущие программисты, читающие это в коде, не будут ожидать, что это произойдет.
Это потому, что мы неправильно используем `Deref`. Признак Deref предназначен для реализации пользовательских типов указателей. Цель состоит в том, чтобы он принимал указатель на T, а не выполнял преобразование между различными типами.

Это еще и потому, что механизм здесь совершенно неявный.

Наконец, этот шаблон поддерживает только одиночное наследование и не имеет понятия об интерфейсах, конфиденциальности на основе классов или других функциях, связанных с наследованием. Таким образом, это дает опыт, который будет слегка удивить программистов, привыкших к наследованию Java и т. д.

**Обсуждение**

Нет ни одной хорошей альтернативы. В зависимости от конкретных обстоятельств может быть лучше повторно реализовать использование признаков или написать фасадные методы для ручной диспетчирезации Foo. 

## [Золотой молоток (Golden hammer)](https://habr.com/ru/articles/59005/)

Золотой молоток — уверенность в полной универсальности любого решения. На практике, это — применение одного решения (чаще всего какого-либо одного паттерна проектирования) для всех возможных и невозможных задач. Попытка решить все задачи единственным методом, который знаком. Для каждой задачи имеется не одно, а несколько, красивых и оптимальных решений — именно к поиску таких решений и сводится эффективная разработка. 

## Мягкое кодирование (Soft code)/ Жёсткое кодирование (Hard code)

Перед началом решения определённой задачи следует определить, что должно быть настариваемым, а что является постоянным для различных систем или может быть настроено автоматически.

# [Anti-patterns sourcemaking.com](https://sourcemaking.com/antipatterns)

## [Антипаттерны разработки программного обеспечения](https://sourcemaking.com/antipatterns/software-development-antipatterns)

Антипаттерн возникает без рефакторинга.
Полезные форм рефакторинга программного обеспечения.
Рефакторинг программного обеспечения — это форма модификации кода, используемая для улучшения структуры программного обеспечения для поддержки последующего расширения и долгосрочного обслуживания. В большинстве случаев цель состоит в том, чтобы преобразовать код, не влияя на его корректность.

#### [Дизайн в процедурном стиле Blob](https://sourcemaking.com/antipatterns/the-blob)

приводит к тому, что один объект несет львиную долю обязанностей, в то время как большинство других объектов только хранят данные или выполняют простые процессы. Решение включает в себя рефакторинг конструкции для более равномерного распределения обязанностей и изоляции эффекта изменений.

#### [Технология непрерывного устаревания](https://sourcemaking.com/antipatterns/continuous-obsolescence)

меняется так быстро, что разработчикам часто трудно идти в ногу с текущими версиями программного обеспечения и находить комбинации выпусков продуктов, которые работают вместе. Учитывая, что каждая линейка коммерческих продуктов развивается за счет новых выпусков, разработчикам становится все труднее справиться с этой ситуацией. Найти совместимые версии продуктов, которые успешно взаимодействуют друг с другом, еще сложнее.

#### [Lava Flow](https://sourcemaking.com/antipatterns/lava-flow)

Мертвый код и забытая информация о дизайне заморожены в постоянно меняющемся дизайне. Это аналог потока лавы с затвердевающими каплями каменного материала. Рефакторинговое решение включает в себя процесс управления конфигурацией, который устраняет мертвый код и развивает или реорганизует дизайн в целях повышения качества.

#### [Неоднозначная точка зрения](https://sourcemaking.com/antipatterns/ambiguous-viewpoint)

Модели объектно-ориентированного анализа и проектирования (OOA&D) часто представляются без разъяснения точки зрения, представленной моделью. По умолчанию модели OOA&D обозначают точку зрения реализации, которая потенциально наименее полезна. Смешанные точки зрения не позволяют фундаментально отделить интерфейсы от деталей реализации, что является одним из основных преимуществ объектно-ориентированной парадигмы.

#### [Функциональная декомпозиция](https://sourcemaking.com/antipatterns/functional-decomposition)

Этот антипаттерн является результатом работы опытных необъектно-ориентированных разработчиков, которые проектируют и реализуют приложение на объектно-ориентированном языке. Полученный код по структуре классов напоминает структурный язык (Паскаль, ФОРТРАН). Это может быть невероятно сложно, поскольку умные процедурные разработчики изобретают очень «умные» способы воспроизвести свои проверенные временем методы в объектно-ориентированной архитектуре.

#### [Полтергейсты](https://sourcemaking.com/antipatterns/poltergeists)

Полтергейсты — это классы с очень ограниченными ролями и эффективным жизненным циклом. Они часто запускают процессы для других объектов. Рефакторинговое решение включает в себя перераспределение обязанностей на долгоживущие объекты, устраняющие полтергейста.

#### [Лодочный якорь](https://sourcemaking.com/antipatterns/boat-anchor)
Лодочный якорь — это часть программного или аппаратного обеспечения, которая не служит никакой полезной цели в текущем проекте. Часто лодочный якорь является дорогостоящим приобретением, что делает покупку еще более ироничной.

#### [Золотой молоток](https://sourcemaking.com/antipatterns/golden-hammer)
Золотой молоток — это знакомая технология или концепция, которая одержимо применяется для решения многих проблем программного обеспечения. Решение предполагает расширение знаний разработчиков посредством образования, обучения и групп по изучению книг, чтобы познакомить разработчиков с альтернативными технологиями и подходами.

#### [Тупик](https://sourcemaking.com/antipatterns/dead-end)
Тупик достигается путем модификации повторно используемого компонента, если модифицированный компонент больше не обслуживается и не поддерживается поставщиком. При внесении этих изменений бремя поддержки переходит к разработчикам и сопровождающим системы приложений. Улучшения в многоразовом компоненте нелегко интегрировать, и в проблемах с поддержкой можно винить модификацию.

#### [Спагетти-код](https://sourcemaking.com/antipatterns/spaghetti-code)

Специальная структура программного обеспечения затрудняет расширение и оптимизацию кода. Частый рефакторинг кода может улучшить структуру программного обеспечения, поддержать его обслуживание и обеспечить итеративную разработку.

#### [Input Kludge](https://sourcemaking.com/antipatterns/input-kludge)

обеспечение, которое не проходит простые поведенческие тесты, может быть примером входного кладджа, который возникает, когда для обработки входных данных программы используются специальные алгоритмы.

#### [Прогулка по минному полю](https://sourcemaking.com/antipatterns/walking-through-minefield)

Использование современных программных технологий аналогично прохождению по высокотехнологичному минному полю. В выпущенных программных продуктах обнаруживаются многочисленные ошибки; Фактически, по оценкам экспертов, исходный код содержит от двух до пяти ошибок на строку кода.

#### [Повторное использование программного кода методом вырезания и вставки](https://sourcemaking.com/antipatterns/cut-and-paste-programming)

путем копирования исходных операторов приводит к серьезным проблемам сопровождения. Альтернативные формы повторного использования, включая повторное использование «черного ящика», уменьшают проблемы с обслуживанием за счет наличия общего исходного кода, тестирования и документации.

#### [Грибовидное управление](https://sourcemaking.com/antipatterns/mushroom-management)
В некоторых кругах, занимающихся архитектурой и менеджментом, существует четкая политика изоляции разработчиков систем от конечных пользователей системы. Требования передаются из вторых рук через посредников, включая архитекторов, менеджеров или аналитиков требований.

## [Антипаттерны архитектуры программного обеспечения](https://sourcemaking.com/antipatterns/software-architecture-antipatterns)

Разработка программного обеспечения на основе архитектуры — наиболее эффективный подход к созданию систем. 
Подходы, основанные на архитектуре, превосходят подходы, основанные на требованиях, документах и ​​методологии. Проекты часто достигают успеха вопреки методологии, а не благодаря ей.

#### [Автоматически создаваемая дымоход.](https://sourcemaking.com/antipatterns/autogenerated-stovepipe)

Этот антипаттерн возникает при переносе существующей программной системы в распределенную инфраструктуру. Автогенерированная дымоход возникает при преобразовании существующих программных интерфейсов в распределенные интерфейсы. Если один и тот же дизайн используется для распределенных вычислений, возникает ряд проблем.

#### [Предприятие по производству дымоходов](https://sourcemaking.com/antipatterns/stovepipe-enterprise)

Система дымоходов характеризуется структурой программного обеспечения, которая препятствует изменениям. Рефакторинговое решение описывает, как абстрагировать подсистему и компоненты для достижения улучшенной структуры системы. Антипаттерн Stovepipe Enterprise характеризуется отсутствием координации и планирования в ряде систем.

#### [Беспорядок](https://sourcemaking.com/antipatterns/jumble)

Когда горизонтальные и вертикальные элементы дизайна смешиваются, получается нестабильная архитектура. Смешение горизонтальных и вертикальных элементов конструкции ограничивает возможность повторного использования и надежность архитектуры и компонентов системного программного обеспечения.

#### [Подсистемы дымоходной системы](https://sourcemaking.com/antipatterns/stovepipe-system)

интегрируются специальным образом с использованием множества стратегий и механизмов интеграции, и все они интегрированы по точкам. Подход к интеграции каждой пары подсистем нелегко применить к подходам других подсистем. AntiPattern Stovepipe System — это односистемный аналог Stovepipe Enterprise, который касается того, как подсистемы координируются внутри единой системы.

#### [Прикрывайте свои активы](https://sourcemaking.com/antipatterns/cover-your-assets)

Программные процессы, основанные на документах, часто создают малополезные требования и спецификации, поскольку авторы уклоняются от принятия важных решений. Чтобы не допустить ошибки, авторы идут более безопасным путем и разрабатывают альтернативные варианты.

#### [Привязка к поставщику](https://sourcemaking.com/antipatterns/vendor-lock-in)

Привязка к поставщику возникает в системах, которые сильно зависят от проприетарных архитектур. Использование слоев архитектурной изоляции может обеспечить независимость от решений конкретных поставщиков.

#### [Wolf Ticket](https://sourcemaking.com/antipatterns/wolf-ticket)

Wolf Ticket — это продукт, который заявляет об открытости и соответствии стандартам, которые не имеют обязательного значения. Продукты поставляются с собственными интерфейсами, которые могут существенно отличаться от опубликованного стандарта.

#### [Архитектура по смыслу](https://sourcemaking.com/antipatterns/architecture-by-implication)

Управление рисками при последующей разработке системы часто упускается из виду из-за чрезмерной самоуверенности и недавних успехов системы. Общий подход к архитектуре, адаптированный к каждой прикладной системе, может помочь выявить уникальные требования и области риска.

#### [В проектах Warm Bodies](https://sourcemaking.com/antipatterns/warm-bodies)

Software часто работают программисты с самыми разными навыками и уровнями производительности. Многие из этих людей могут быть назначены для достижения целей по численности персонала (так называемые «теплые тела»). Квалифицированные программисты необходимы для успеха программного проекта. Так называемые героические программисты исключительно продуктивны, но лишь один из 20 обладает этим талантом. Они производят на порядок больше работающего программного обеспечения, чем среднестатистический программист.

#### [Проектирование комитетом](https://sourcemaking.com/antipatterns/design-by-committee)

Классический антипаттерн органов стандартизации, Дизайн комитетом, создает слишком сложную архитектуру, которой не хватает последовательности. Уточнение архитектурных ролей и улучшение упрощения процессов могут превратить плохие процессы встреч в высокопродуктивные мероприятия.

#### [Швейцарский армейский нож](https://sourcemaking.com/antipatterns/swiss-army-knife)

Швейцарский армейский нож — это слишком сложный интерфейс классов. Разработчик пытается предусмотреть все возможные варианты использования класса. При этом он или она добавляет большое количество сигнатур интерфейсов в тщетной попытке удовлетворить все возможные потребности.

#### [Изобретите велосипед заново.](https://sourcemaking.com/antipatterns/reinvent-the-wheel)

Повсеместное отсутствие передачи технологий между программными проектами приводит к существенному переосмыслению. Знания в области проектирования, спрятанные в устаревших активах, можно использовать для сокращения времени выхода на рынок, затрат и рисков.

#### [Великий Старый Герцог Йоркский](https://sourcemaking.com/antipatterns/the-grand-old-duke-of-york)

Эгалитарные процессы разработки программного обеспечения часто игнорируют таланты людей в ущерб проекту. Навыки программирования не приравниваются к навыкам определения абстракций. Судя по всему, в разработке программного обеспечения участвуют две отдельные группы: абстракционисты и имплементаторы.

## [Управление программными проектами](https://sourcemaking.com/antipatterns/software-project-management-antipatterns)

В современной инженерной профессии более половины работы связано с человеческим общением и решением человеческих проблем. 
Антипаттерны управления определяют некоторые ключевые сценарии, в которых эти проблемы разрушительны для процессов программного обеспечения.

#### Blowhard Jamboree

Мнения так называемых отраслевых экспертов часто влияют на технологические решения. В популярных СМИ и частных изданиях часто появляются противоречивые сообщения с критикой отдельных технологий. Помимо технических обязанностей, разработчики тратят слишком много времени на ответы на вопросы менеджеров и лиц, принимающих решения, возникающие в результате этих отчетов.


















/*
Позволяет эффективно работать коду, благодаря наличию реализованных стратегий основываясь на входных данных.
Все стратегии реализуются по обшему интерфейсу и соответственно код становится гибким/взаимозаменяемым.
Это позволяет отказаться от использования переключателей и/или условных операторов.
К примеру выбор способа сортировки зависит от типа и размера данных, соответственно выбирая подходящий алгоритм мы используем паттерн стратегия.

Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к `Template Strategy`.

Одно из преимуществ использования `Template Strategy` заключается в том, что мы можем избавиться от ветвления `if/else`.
Достигается это за счет того, что `Client` "знает",
какой алгоритм он хочет использовать и передает объект алгоритма в конструктор класса - `Context`. 
Согласно `Singl responsibility` разделяем классы на подклассы.

Один из принципов SOLID: open/close - предполагает сущность открыта для расширения но закрыта для модификаций. Таким образом при надобности расширить
поведение сущности мы просто добавляем еще одну стратегию, вместо изменения кода сущности.

Мотивы
Программа должна обеспечивать различные варианты алгоритма или поведения
Нужно изменять поведение каждого экземпляра класса
Необходимо изменять поведение объектов на стадии выполнения
Введение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы


Эмпирические правила:

- `Template Strategy` похожа на `Template Method`, за исключением степени детализации.

- `Template State` похож на `Template Strategy`, за исключением своего намерения.

- `Template State, Strategy, Bridge` (и в некоторой степени `Template Adapter`) имеют схожие структуры решений. 
Все они разделяют элементы идиомы «handle/body». Они различаются по назначению – то есть решают разные задачи.

- `Template Strategy` имеет две разные реализации, первая похожа на `Template State`. 
Разница заключается во времени привязки (`Template Strategy` — это шаблон с однократной привязкой, тогда как `Template State` более динамичен).
Объекты стратегии часто становятся хорошими легковесами.

-`Template Strategy` позволяет вам изменить внутренности объекта. `Template Decorator` позволяет менять скин.
И `Template Strategy`, и `Template Decorator` могут применяться для изменения поведения конкретных классов. 
Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более удобным, а недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.

Состоит:

 - Strategy - абстрактная сущность 

 - ConcreteStrategy - конкретные реализации стратегии 

 - Context - содержит конкретную стратегию

 - Client - выбирает какую стратегию применять
*/

/*
Задача
Представьте, что мы работаем над проектом, который генерирует отчеты каждый месяц. 
Нам нужно, чтобы отчеты формировались в разных форматах (стратегиях), например в формате JSON или Plain Text. 
Но со временем ситуация меняется, и мы не знаем, какие требования мы можем получить в будущем. 
Например, нам может потребоваться создать отчет в совершенно новом формате или просто изменить один из существующих форматов.
*/
use std::collections::HashMap;

type Data = HashMap<String, u32>;

// Strategy
trait Formatter {
    fn format(&self, data: &Data, buf: &mut String);
}

// ConcreteStrategy
struct Report;
impl Report {
    // Следует использовать trait Write, но мы используем String, чтобы игнорировать обработку ошибок.
    fn generate<T: Formatter>(g: T, s: &mut String) {
        // backend operations...
        let mut data = HashMap::new();
        data.insert("one".to_string(), 1);
        data.insert("two".to_string(), 2);
        // generate report
        g.format(&data, s);
    }
}

// ConcreteStrategy
struct Text;
impl Formatter for Text {
    fn format(&self, data: &Data, buf: &mut String) {
        for (k, v) in data {
            let entry = format!("{} {}\n", k, v);
            buf.push_str(&entry);
        }
    }
}

// ConcreteStrategy
struct Json;
impl Formatter for Json {
    fn format(&self, data: &Data, buf: &mut String) {
        buf.push('[');
        for (k, v) in data.into_iter() {
            let entry = format!(r#"{{"{}":"{}"}}"#, k, v);
            buf.push_str(&entry);
            buf.push(',');
        }
        if !data.is_empty() {
            buf.pop(); // remove extra, at the end
        }
        buf.push(']');
    }
}

// cargo run --example p_behavior_strategy
fn main() {
    // Context/Client

    let mut s = String::from("");
    Report::generate(Text, &mut s);
    assert!(s.contains("one 1"));
    assert!(s.contains("two 2"));

    s.clear(); // reuse the same buffer
    Report::generate(Json, &mut s);
    assert!(s.contains(r#"{"one":"1"}"#));
    assert!(s.contains(r#"{"two":"2"}"#));
}
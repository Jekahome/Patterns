
# Single Responsibility Principle (SRP)

**SRP Singl resposibility** - принцып единственной ответственности (обязанности) класса/модуля
У класса/модуля должна быть одна причина для изменения, если их больше то у него несколько ответственностей/обязаностей.
Лишние обязанности класса сильно связывают его с всеми ими сразу, любое изменение одной обязанности влечет изменение 
этого класса, высокая нестабильность.
Есть принцип - "ф-ции должна делать что-то одно и только одно" т.е. при нарушении метод берет на себя разные 
обязанности и подвержен множеству поводов для изменения, но это не относится к SRP принципу! 
Модуль должен отвечать за одну группу сущностей и только за одну.
Причина для изменения - это группа сущностей/actors которые работают с модулем, эта группа должна быть единственной.
Модуль - это "связный" набор функций и структур данных т.е. это может быть классом.
"Связный" - это сила, которая связывает код, ответственный за единственну группу сущностей, т.е. это может быть реализация интерфейса 
Решение:  Реализовать для каждой группы сущностей свой класс используя паттерн Фасад и вынести зависимости за абстракцию.

Принцип единственной ответственности (Single Responsibility Principle(SRP)) касается функций и классов, но он проявляется в разных формах на еще двух, более высоких уровнях. На уровне компонентов он превращается в принцип согласованного изменения (Common Closure Principle(CCP)),а на архитектурном уровне — в принцип оси изменения (Axis of Change), отвечающий за создание архитектурных границ. 

# Open/Closed Principle (OCP)

**Open/close** - класс открыт для расширения но закрыт для модификаций 
Простая для изменения система должна предусматривать простую возможность изменения ее поведения добавлением нового, но не изменением существующего кода (т.е. когда при изменении поведения класса нам не нужно при этом изменять его код, при изменении источника базы нам не потребуется менять код класса)
(реализуется  через композицию при изменении поведения не нужно менять код класса или через шаблон Strategy)
(Пример: класс квадрат и треугольник подписаны на интерфейс с методом area - подсчет площади, каждый класс реализует 
его по своему, теперь код работающий с этим интерфейсом не подвержен особенностям формирования площади фигур)

Программные сущности должны быть открыты для расширения и закрыты для изменения.
Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения.
Пример: кроме отчета на экран добавить отчет в PDF, так что бы добавился только модуль PDF без изменения текущего кода

Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. 
Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, 
защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже. Разработчик библиотеки должен оставить места в коде для возможности вставки кода изменения поведения дальнейшей работы.

# Liskov Substitution Principle (LSP)

**Liskov** - наследуемый класс должен добавлять, а не изменять функционал базового класса. 
В двух словах, этот принцип утверждает, что для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту,который позволяет заменять эти части друг другом.
  
Принцип гласит, что объекты должны быть заменены экземплярами их подтипов без изменения правильного функционирования нашей системы. 
Подтипы (полиморфные типы, связь через интерфейсы) должны быть взаемозаменяемы.

Проще говоря, LSP устанавливает, что при переопределении метода в подклассе он должен удовлетворять следующим требованиям:

1. Его сигнатура должна совпадать с сигнатурой его родителя

2. Его предпосылки (что принимать) должны быть такими же или более слабыми.

3. Условия размещения (чего ожидать) должны быть такими же или более сильными.

4. Исключения (если есть) должны быть того же типа, что и исключения, созданные его родителем.
 
**Принцип замещения Лискова** утверждает, что подтипы должны быть подменяемы для базовых типов.

Класс ребенка не должен:
Удалить поведение базового класса
Нарушить инварианты базового класса

Нарушение принципа подстановки:
Есть объект транспорт у него есть методы ускорение и торможение на определенное количество единиц
Наследуемся от него Ускоренным объектом который быстрее ускоряется
Но теперь новый объект наследник мы не сможем подставить в код для родителя так как он ускоряется быстро а останавливается как родитель медленно

Это нарушение взаимозаменяемости и ожидаемого поведения объекта 
когда вы вызываете Foo родителя на производном объекте, он дает точно такие же результаты, как вызов Foo для базового объекта, если входные параметры были одинаковы.


# Interface Segregation Principle (ISP)

**Interface segregation** - разделение большого интерфейса на маленькие по обязанностям.
Класс не должен быть подписан на методы которые он не использует.
Для статически типизированных языков это более затратно чем для динамичски типизированных языков, ведь при
 изменении метода с которым работает одна зависимость придется перекомпилировать независимые классы,
а для динамических языков это происходит и так при каждом запуске выполнения скрипта.
Т.е. это проблема статичских языков, а не архитектуры.
Так как статическая типизация завязана на типе статически и при изменении типа так же должна быть перекомпилированна,
а динамический тип соберется в процессе запуска и не подвержен изменениям не используемых методов интерфейса. 


# Dependency Inversion Principle (DIP)

**Dependency inversion** - не зависить от конкретных реализаций, только от абстракций (от интерфейса)
В нем говорится, что модуль высокого уровня не должен зависеть от модуля низкого уровня,но они должны зависеть от абстракций.
Этот принцип позволяет разделить и повторно использовать код.
Для управления нежелательными зависимостями используют шаблон "Абстрактная фабрика"

Откуда появился термин инверсия зависимостей.
До появления механизма  полиморфизма программа следова четко по направлению зависомостей вызывающих ф-ций и потоком управления считывания данных строк кода.
Т.е. поток управления определяется поведением системы, а зависимости исходного кода определяются этим потоком управления.
Однако когда в игру включился полиморфизм, стало возможным нечто совершенно иное, возможность зависеть не от вызываемых ф-ций, а от реализующих их абстракций/интерфейсов позволила не следовать прямолинейному направлению и теперь поток напрвления не ограничивает ход программы.
### Что такое паттерны, зачем и почему?

Способ решения часто встречающихся задач. 
Они делают наше программное обеспечение более модульным, удобным в сопровождении и расширяемым. 
Более того, эти шаблоны предоставляют разработчикам общий язык, что делает их отличным инструментом для эффективного общения при решении проблем в группах.


### Подходят ли ООП паттерны для Rust?

Rust - статически типизированный язык системного уровня программирования, с парадигмой функционального и процедурного стиля. Используется не только для системного программирования интрументария но и для прикладных программ пользователю, WEB бэкенд и фронтенд, игр, встроенных систем микроконтроллеров.

В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций.
Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.
Парадигмы - это стили написания кода, в Rust есть возможности структурировать код в функциональном стиле используя методы итератора,вектора или собственными силами соблюдая правила:
неизменяемость данных,чистые функции(не имеют побочных эффектов),композиция функций(объединения нескольких функций в одну),функции высшего порядка(принимают другие функции в качестве аргументов или возвращают),отсутвие операций присвоения для сохранения промежуточных результатов вызовов функций.

Так же сможем придерживаться процедурного стиля, компоновать код для повторного использования с применением присвоения для сохранением промежуточных данных между вызовами процедур. 
И это не запрещает нам структурировать код в ООП стиле (нет наследования данных и реализаций, только интерфейсов через super-trait, есть инкапсуляция c помошью mod и есть полиморфизм c помощью trait-object и параметрический полиморфизм дженериков и ограничение трейтами). 
Сдедовательно, только наши цели (предметная область) и ограничения или особенности языка (идиомы), задают каким образом использовать паттерны.  

**Императив**
```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

**Декларативный**
```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```
Помните, что в декларативных программах мы описываем, **ЧТО** делать, а не **КАК** это делать. 

`fold` это функция, которая составляет функции.

Также благодаря `static dispatch` мы можем вынести потенциальные ошибки использования типов на этап компиляции кода.  
Система типов Rust может превратить многие виды проблем программирования в проблемы `static dispatch`. 
Это одно из самых больших преимуществ при выборе функционального языка, и оно имеет решающее значение для многих гарантий времени компиляции Rust.
В Rust параметр универсального типа создает то, что в функциональных языках называется «**ограничением класса типа**».
Это называется **мономорфизацией**, когда разные типы создаются из полиморфного кода.

**Альтернативы**

Если типу требуется «разделенный API» из-за конструкции или частичной инициализации, вместо этого рассмотрите **Builder Pattern**.

Если API между типами не меняется — меняется только поведение — тогда лучше использовать **Strategy Pattern**.

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Rust%20idioms.png "Rust idioms")

Рекомендации, которым следует следовать при кодировании. Это согласованные нормы общества. Нарушать их следует только в том случае, если у вас есть для этого веская причина.

[Rust idioms rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)

[Rust idioms rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/index.html)

[Rust idioms rust-unofficial github](https://github.com/Jekahome/RustDesignPatterns/tree/main/src/idioms)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Anti%20patterns.png "Anti patterns")

Методы решения распространенных проблем при кодировании. Однако, хотя шаблоны проектирования дают нам преимущества, антишаблоны создают больше проблем.


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20principles.png "Design principles")

### Design principles: SOLID

Принцип единой ответственности (SRP): класс должен иметь только одну ответственность, то есть только изменения в одной части спецификации программного обеспечения должны иметь возможность повлиять на спецификацию класса.

Принцип открытости/закрытости (OCP): «Программные объекты… должны быть открыты для расширения, но закрыты для модификации».

Принцип замены Лискова (LSP): «Объекты в программе должны быть заменены экземплярами их подтипов без изменения корректности этой программы».

Принцип разделения интерфейсов (ISP): «Многие клиентские интерфейсы лучше, чем один интерфейс общего назначения».

Принцип инверсии зависимостей (DIP): нужно «зависеть от абстракций, а не от конкретики».

### Design principles: KISS

Большинство систем работают лучше всего, если их сохранять простыми, а не усложнять; следовательно, простота должна быть ключевой целью проектирования, и следует избегать ненужной сложности.
Простота кода – превыше всего, потому что простой код – наиболее понятный.
Если вы используете паттерн проектирования там, где нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код. 
Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
Моя интерпритация KISS - соблюдать необходимые рекомендации разработки проекта чтобы, в момент когда проект достигнет немалых масштабов и потребуется вносить изменения, то разработчик мог это сделать малыми силами. Для этого, помимо использования общеизвестных паттернов и идиом технологии/языка если они уместны, должна быть в наличии документация, тесты, необходимые комментарии, ссылки на источники, само собой разумеется SOLID, содержательные имена. К тому же, архитектура приложения должна предусматривать внесение вероятных изменений.  

[KISS — принцип проектирования, содержащий все остальные принципы проектирования](https://habr.com/ru/articles/249639/)

### Design principles: DRY

"**Не повторяйте себя.**"

Короче говоря, всякий раз, когда вы ловите себя на том, что пишете один и тот же код дважды, у вас есть возможность стать более эффективным.
Следование этому принципу означает, что ваша цель — сократить количество повторяющихся шаблонов и дублирования кода и логики в пользу модульного кода, на который можно ссылаться т.е. использовать повторно.

В книге «Программист-прагматик» мы можем увидеть такое определение DRY:
«Каждая часть знаний должна иметь единственное, однозначное и авторитетное представление в системе»

Это означает, что у вас не должно быть дублированного кода. Легче поддерживать код, который находится только в одном месте, потому что если вам нужно что-то изменить в коде, вам просто нужно изменить это в одном месте. Кроме того, если у вас есть один и тот же код в двух или более местах, вероятность того, что этот код со временем станет другим, высока, и когда это произойдет, это станет простым способом внести ошибки в вашу систему. Дублированный код также делает код более сложным и неоправданно большим.

### Design principles: YAGNI 

"**Тебе это не понадобится**"

Это означает, что вам не следует реализовывать функциональность только потому, что вы думаете, что она вам когда-нибудь понадобится, а реализовывать ее только тогда, когда она вам действительно понадобится. Поступая так, вы избежите траты времени на реализации, которые даже не были необходимы и, возможно, никогда не будут использоваться.

[Design principles](https://rust-unofficial.github.io/patterns/additional_resources/design-principles.html)

[dry-kiss-yagni-principles](https://henriquesd.medium.com/dry-kiss-yagni-principles-1ce09d9c601f)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20patterns.png "Design patterns")

Методы решения распространенных проблем при кодировании.

**Порождающие паттерны**

Паттерны которые создают новые объекты, или позволяют получить доступ к уже существующим. То есть те шаблоны, по которым можно создать новый автомобиль и как это лучше сделать.

**Структурирующие паттерны**

Данные паттерны помогают внести порядок и научить разные объекты более правильно взаимодействовать друг с другом.

**Паттерны поведения**

Эта группа паттернов позволяет структурировать подходы к обработке поведения и взаимодействия объектов. Проще говоря, как должны проходить процессы в которых существует несколько вариантов протекания событий.

[Rust patterns](https://rust-unofficial.github.io/patterns/)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

## Принципы DDD 

...

## Слоеная архитектура 

...

## CQRS-ES

...

 

### CQRS-ES

Разделение команд-запросов (CQS) «Функции не должны вызывать абстрактные побочные эффекты... только команды (процедуры) могут вызывать побочные эффекты». - Бертран Мейер: Объектно-ориентированное создание программного обеспечения

--------------

Куда складывать:
- Google Диск Exel Manual/Rust(Patterns/Algorithms)
- Google Диск Exel Manual/Patterns
- GitHub Jekahome/Pattrens

Источники:
- книги ../DesignPatterns_AndriyBuday
- книги ../Design-Patterns.md
- книги ../Разработка интерфейсов.паттерны проектирования.Дженифер Тидвелл
- книги ../Head_First_Паттерны_проектирования_2022_Эрик_Фримен,_Элизабет_Робсон
- код ../Patterns_Others_lang
- код ../Patterns_Rust_PHP_TypeScript

[Rust Design Patterns](https://rust-unofficial.github.io/patterns/)


[Rust Design Patterns rust-unofficial](https://github.com/rust-unofficial/patterns)
[Rust Design Patterns refactoring.guru](https://refactoring.guru/ru/design-patterns/rust)
 

[Реализация конечного автомата (переходы между состояниями)](https://hoverbear.org/blog/rust-state-machine-pattern/)

[шаблон Состояние (+exel example)](https://doc.rust-lang.ru/book/ch17-03-oo-design-patterns.html)

### ООП паттерны
[Rust Design Patterns](https://chercher.tech/rust/observer-design-pattern-rust)
[Паттерны проектирования](http://design-pattern.ru/patterns/)
[Каталог шаблонов архитектуры корпоративных приложений](https://martinfowler.com/eaaCatalog/index.html)


[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

[Что такое анти-паттерны?](https://habr.com/ru/articles/59005/)


### DesignPatternsPHP
[DesignPatternsPHP 1](https://designpatternsphp.readthedocs.io/ru/latest/index.html)
[DesignPatternsPHP github](https://github.com/domnikl/DesignPatternsPHP)
[DesignPatternsPHP 2](https://dron.by/)


[«Паттерны» функционального программирования](https://habr.com/ru/articles/337880/)

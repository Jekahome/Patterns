### Что такое паттерны, зачем и почему?

Способ решения часто встречающихся задач. 
Они делают наше программное обеспечение более модульным, удобным в сопровождении и расширяемым. 
Более того, эти шаблоны предоставляют разработчикам общий язык, что делает их отличным инструментом для эффективного общения при решении проблем в группах.

Лучшее понимание паттернов и алгоритмов, повышает гибкость мышления и качество конечного продукта.
Глобально, Мир станет совершеннее если перестать **плодить** мусор. Следует различать **создание** мусора в процессе разработки с последующим его рефакторингом, и конечный результат в виде мусора (**плодить**), так как он остается на обозрение пользователей.

### Подходят ли ООП паттерны для Rust?

Rust - статически типизированный язык системного уровня программирования, с парадигмой функционального и процедурного стиля. Используется не только для системного программирования интрументария но и для прикладных программ пользователю, WEB бэкенд и фронтенд, игр, встроенных систем микроконтроллеров.

В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций.
Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.

Парадигмы - это стили написания кода, в Rust есть возможности структурировать код в функциональном стиле используя методы итератора,вектора или собственными силами соблюдая правила:
неизменяемость данных,чистые функции(не имеют побочных эффектов),композиция функций(объединения нескольких функций в одну),функции высшего порядка(принимают другие функции в качестве аргументов или возвращают),отсутвие операций присвоения для сохранения промежуточных результатов вызовов функций.

Так же сможем придерживаться процедурного стиля, компоновать код для повторного использования с применением присвоения для сохранением промежуточных данных между вызовами процедур. 
И это не запрещает нам структурировать код в ООП стиле (нет наследования данных и реализаций, только интерфейсов через super-trait, есть инкапсуляция c помошью mod и есть полиморфизм c помощью trait-object и параметрический полиморфизм дженериков и ограничение трейтами). 
Сдедовательно, только наши цели (предметная область) и ограничения или особенности языка (идиомы), задают каким образом использовать паттерны.  

**Императив**
```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

**Декларативный**
```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
// `fold` это функция, которая составляет функции.
```
Помните, что в декларативных программах мы описываем, **ЧТО** делать, а не **КАК** это делать. 

Также благодаря `static dispatch` мы можем вынести потенциальные ошибки использования типов на этап компиляции кода.  
Система типов Rust может превратить многие виды проблем программирования в проблемы `static dispatch`. 
Это одно из самых больших преимуществ при выборе функционального языка, и оно имеет решающее значение для многих гарантий времени компиляции Rust.
В Rust параметр универсального типа создает то, что в функциональных языках называется «**ограничением класса типа**».
Это называется **мономорфизацией**, когда разные типы создаются из полиморфного кода.

**Альтернативы**

Если типу требуется «раздельнный API» из-за конструкции или частичной инициализации, вместо этого рассмотрите **Builder Pattern**.

Если API между типами не меняется — меняется только поведение — тогда лучше использовать **Strategy Pattern** 
(в Rust нет необходимости в шаблоне стратегии , потому что мы можем просто использовать трейты :thinking:).

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Rust%20idioms.png "Rust idioms")

Рекомендации, которым следует следовать при кодировании. Это согласованные нормы общества. Нарушать их следует только в том случае, если у вас есть для этого веская причина.

- Type safety (Newtype, Typestates) 

- Mem replace (hook lifetime)

- Bound impl (ограничение поведения)

- Generic in type out (абстракция аргументов)

- Exhaustivity (проверка на полноту вариантов)

- Sealing (запечатывание реализации)

- Конструктор с помощью ф-ции `new` и конструктор по умолчанию `Default`

- Динамическая диспетчеризация на стеке

- Передача переменных в замыкание 

- Временная мутабельность

- Возвращать использованный аргумент при ошибке

[Rust idioms rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)

[Rust idioms rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/index.html)

[Rust idioms rust-unofficial github](https://github.com/Jekahome/RustDesignPatterns/tree/main/src/idioms)

[Реализация конечного автомата (переходы между состояниями)](https://hoverbear.org/blog/rust-state-machine-pattern/)

[шаблон Состояние](https://doc.rust-lang.ru/book/ch17-03-oo-design-patterns.html)

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Anti%20patterns.png "Anti patterns")

Методы решения распространенных проблем при кодировании. Однако, хотя шаблоны проектирования дают нам преимущества, антишаблоны создают больше проблем.

- Клонирование для проверки заимствований (borrow checker)

- Использование подавление предупреждений компилятора при сборке

- Неправильное использование трейта `Deref`

- Золотой молоток (Golden hammer)

- Мягкое кодирование (Soft code)/ Жёсткое кодирование (Hard code)

[Anti patterns sourcemaking.com](https://sourcemaking.com/antipatterns)

- [Антипаттерны разработки программного обеспечения](https://sourcemaking.com/antipatterns/software-development-antipatterns)

- [Антипаттерны архитектуры программного обеспечения](https://sourcemaking.com/antipatterns/software-architecture-antipatterns)

- [Управление программными проектами](https://sourcemaking.com/antipatterns/software-project-management-antipatterns)

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20principles.png "Design principles")

### Design principles: SOLID

Принцип единой ответственности (SRP): класс должен иметь только одну ответственность, то есть только изменения в одной части спецификации программного обеспечения должны иметь возможность повлиять на спецификацию класса.

Принцип открытости/закрытости (OCP): «Программные объекты… должны быть открыты для расширения, но закрыты для модификации».

Принцип замены Лискова (LSP): «Объекты в программе должны быть заменены экземплярами их подтипов без изменения корректности этой программы».

Принцип разделения интерфейсов (ISP): «Интерфейс отвечающий за одну область задач лучше, чем один интерфейс общего назначения».

Принцип инверсии зависимостей (DIP): нужно «зависеть от абстракций, а не от конкретики».

### Design principles: KISS

Большинство систем работают лучше всего, если их сохранять простыми, а не усложнять; следовательно, простота должна быть ключевой целью проектирования, и следует избегать ненужной сложности.
Простота кода – превыше всего, потому что простой код – наиболее понятный.
Если вы используете паттерн проектирования там, где нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код. 
Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.

Моя интерпритация KISS - соблюдать необходимые рекомендации разработки проекта чтобы, в момент когда проект достигнет немалых масштабов и потребуется вносить изменения, то разработчик мог это сделать малыми силами. Для этого, помимо использования общеизвестных паттернов и идиом технологии/языка если они уместны, должна быть в наличии документация, тесты, необходимые комментарии, ссылки на источники, само собой разумеется SOLID, содержательные имена. К тому же, архитектура приложения должна предусматривать внесение вероятных изменений.  

[KISS — принцип проектирования, содержащий все остальные принципы проектирования](https://habr.com/ru/articles/249639/)

### Design principles: DRY

"**Не повторяйте себя.**"

Короче говоря, всякий раз, когда вы ловите себя на том, что пишете один и тот же код дважды, у вас есть возможность стать более эффективным.
Следование этому принципу означает, что ваша цель — сократить количество повторяющихся шаблонов и дублирования кода и логики в пользу модульного кода, на который можно ссылаться т.е. использовать повторно.

В книге «Программист-прагматик» мы можем увидеть такое определение DRY:
«Каждая часть знаний должна иметь единственное, однозначное и авторитетное представление в системе»

Это означает, что у вас не должно быть дублированного кода. 
Легче поддерживать код, который находится только в одном месте, потому что если вам нужно что-то изменить в коде, вам просто нужно изменить это в одном месте. 
Кроме того, если у вас есть один и тот же код в двух или более местах, вероятность того, что этот код со временем станет другим, высока, и когда это произойдет, это станет простым способом внести ошибки в вашу систему.
Дублированный код также делает код более сложным и неоправданно большим.

### Design principles: YAGNI 

"**Тебе это не понадобится**"

Это означает, что вам не следует реализовывать функциональность только потому, что вы думаете, что она вам когда-нибудь понадобится, а реализовывать ее только тогда, когда она вам действительно понадобится. Поступая так, вы избежите траты времени на реализации, которые даже не были необходимы и, возможно, никогда не будут использоваться.

[Design principles](https://rust-unofficial.github.io/patterns/additional_resources/design-principles.html)

[dry-kiss-yagni-principles](https://henriquesd.medium.com/dry-kiss-yagni-principles-1ce09d9c601f)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/Design%20patterns.png "Design patterns")

Методы решения распространенных проблем при кодировании.

## <ins>Порождающие паттерны</ins>

Паттерны которые создают новые объекты, или позволяют получить доступ к уже существующим. 
То есть те шаблоны, по которым можно создать новый автомобиль и как это лучше сделать.

- #### Builder	

Создайте объект с помощью вызовов помощника-строителя.
`Template Builder` — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
`Template Builder` даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
`Template Builder` особенно подходит, когда при построении T есть побочные эффекты, такие как создание потока или запуск процесса.
Полезно, когда в противном случае вам потребовалось бы много конструкторов или когда конструкция имеет побочные эффекты.

Преимущества
Отделяет методы построения от других методов.
Предотвращает распространение конструкторов.
Может использоваться для однострочной инициализации, а также для более сложной конструкции.

Этот шаблон чаще встречается в Rust (и для более простых объектов), чем во многих других языках, поскольку в Rust отсутствует перегрузка. 
Поскольку у вас может быть только один метод с заданным именем, иметь несколько конструкторов в Rust менее удобно, чем в C++, Java или других.

Этот шаблон часто используется там, где объект-строитель полезен сам по себе, а не просто является строителем. 
Например, см [std::process::Command](https://doc.rust-lang.org/std/process/struct.Command.html)
```
    Command::new("sh")
            .arg("-c")
            .arg("echo hello")
            .output()
            .expect("failed to execute process")

```

[Builder rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html)

[Builder](https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)

- #### Fold

Создание новой коллекции посредством изменения элементов применив соответсвующий реализованный алгоритм.

`Template Fold` аналогичен `Template Visitor`, но создает новую версию посещенной структуры данных.
Они разделяют концепцию обхода структуры данных, выполняя операцию на каждом узле. 
Однако посетитель не создает новую структуру данных и не использует старую.

**Мотивация**

Обычно требуется отобразить структуру данных, выполнив некоторую операцию над каждым узлом структуры. 
Для простых операций с простыми структурами данных это можно сделать с помощью `Iterator::map`. 
Для более сложных операций, возможно, когда более ранние узлы могут повлиять на операцию на более поздних 
узлах или где итерация по структуре данных нетривиальна, использование шаблона свертывания является более подходящим.

Как и `Template Visitor`, `Template Fold` позволяет нам отделить обход структуры данных от операций, выполняемых с каждым узлом.


**Обсуждение**

Такое отображение структур данных распространено в функциональных языках. 
В объектно-ориентированных языках более распространено изменение структуры данных на месте. 
«Функциональный» подход распространен в Rust, в основном из-за предпочтения неизменяемости. 
Использование новых структур данных вместо изменения старых в большинстве случаев упрощает анализ кода.

Компромисс между эффективностью и возможностью повторного использования можно изменить, изменив способ приема узлов методами fold_*.

В приведенном выше примере мы работаем с Boxуказателями. Поскольку они владеют исключительно своими данными, 
исходную копию структуры данных нельзя использовать повторно. 
С другой стороны, если узел не изменяется, его повторное использование очень эффективно.

Если бы нам пришлось работать с заимствованными ссылками, исходную структуру данных можно было бы использовать повторно; 
однако узел необходимо клонировать, даже если он не изменился, что может быть дорогостоящим.

Использование указателя с подсчетом ссылок дает лучшее из обоих миров: мы можем повторно использовать исходную структуру данных, 
и нам не нужно клонировать неизмененные узлы. 
Однако они менее эргономичны в использовании и означают, что структуры данных не могут быть изменены.

У итераторов есть fold метод, однако он сворачивает структуру данных в значение, а не в новую структуру данных. 

[Fold rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/creational/fold.html)

- #### Abstract factory	

Его основное назначение - предоставить интерфейс для создания семейства взаимосвязанных объектов, не специфицируя их классы.
Используется в тех случаях, когда необходимо изменять поведение системы,
варьируя создаваемыми объектами, при этом сохраняя интерфейсы. Он позволяет создавать группы взаимосвязанных объектов,
реализующих общее поведение. 
Например, в зависимости от конкретных условий

- #### Factory method	

Для полиморфизма
классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя.

**Достоинства**

позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а оперируя лишь общим интерфейсом;
позволяет установить связь между параллельными иерархиями классов.

**Недостатки**

необходимость создавать наследника Creator для каждого нового типа продукта

- #### Prototype	

Он используется для задания вида создаваемых объектов на основе объекта прототипа, от которого происходит передача внутреннего состояния.

- #### Singelton	

Паттерн Singleton (Одиночка) применяется в том случае, когда какой-либо класс может иметь только один экземпляр (или не иметь ни одного) и легко доступен из глобальной видимости.
 
- #### Object Pool Pattern	

Этот тип шаблона проектирования предоставляет метод повторного использования инициализированных объектов вместо создания новых 
Это позволяет вызвать определенный объект из пула для использования в течение определенного периода времени, 
а затем вернуть его обратно в пул после выполнения задания. 
Во время отсутствия этого объекта никакие другие компоненты не могут использовать его, пока он не будет возвращен обратно в пул.


## <ins>Структурирующие паттерны</ins>

Данные паттерны помогают внести порядок и научить разные объекты более правильно взаимодействовать друг с другом.

- #### Adapter	

`Template Adapter` работает как мост между двумя несовместимыми интерфейсами. 
Эту стратегию можно реализовать с помощью наследования, с помощью агрегации, или композиции, то есть делегирования работы другим объектам.
`Template Adapter` делает два несовместимых интерфейса совместимыми без изменения их существующего кода позволяя им работать вместе.
Adapter это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. 
Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. 

Это работает так:
1. `Template Adapter` имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. `Template Adapter` получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.


Применимость
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
- `Template Adapter` позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

**Отношения с другими паттернами**

`Template Brige` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. 
`Template Adapter` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
`Template Adapter` заставляет вещи работать после того, как они были спроектированы; `Template Brige` заставляет их работать изначально.

`Template Facade` задаёт новый интерфейс, тогда как `Template Adapter` повторно использует старый. 
`Template Adapter` оборачивает только один класс, а `Template Facade` оборачивает целую подсистему. 
Кроме того, `Template Adapter` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

`Template Adapter` предоставляет другой интерфейс для своего объекта. 
`Template Proxy` предоставляет тот же интерфейс. 
`Template Decorator` предоставляет улучшенный интерфейс.

`Template Adapter` предназначен для изменения интерфейса существующего объекта. 
`Template Decorator` улучшает другой объект, не меняя его интерфейс. 
Таким образом, декоратор более прозрачен для приложения, чем адаптер. 
Как следствие, `Template Decorator` поддерживает рекурсивную композицию, что невозможно при использовании чистых адаптеров.

![Adapter](https://github.com/Jekahome/Patterns/blob/main/Adapter.png "Adapter")

[Adapter sourcemaking.com](https://sourcemaking.com/design_patterns/adapter)

[Adapter refactoring.guru](https://refactoring.guru/ru/design-patterns/adapter)

- #### Bridge

`Template Brige` - отделение интерфейса (группа поведений) от реализации (конкретное поведение из группы)

`Template Brige` используется, чтобы избежать увеличения количества подклассов, к которому в конечном итоге могут привести механизмы наследования. 
Итак, если у вас есть, скажем, 2 ортогональные обязанности, то вместо создания 2**2 подклассов вы используете композицию для объединения этих обязанностей.

Учитывая, что любое изменение, внесенное в абстракцию, повлияет на все классы, которые ее реализуют, 
`Template Brige` предлагает добавить **новый уровень абстракции** между обоими элементами, который позволяет разрабатывать каждый из них независимо. 


**Отношения с другими паттернами**

Основное различие между `Template Brige` и `Template Adapter` заключается в том, что `Template Adapter` используется 
для унификации уже существующих интерфейсов, а `Template Brige` используется, когда есть подозрение, что реализация интерфейса со временем изменится.
Т.е. своевременное использование `Template Brige` избавит нас от необходимости внедрять `Template Adapter`

Bridge Before:

![BridgeBefore](https://github.com/Jekahome/Patterns/blob/main/BridgeBefore.png "BridgeBefore")

Bridge After:

![BridgeAfter](https://github.com/Jekahome/Patterns/blob/main/BridgeAfter.png "BridgeAfter")


[Bridge](http://dron.by/post/pattern-proektirovaniya-bridge-most-na-php.html)

[Bridge sourcemaking.com](https://sourcemaking.com/design_patterns/bridge)

[Bridge refactoring.guru](https://refactoring.guru/ru/design-patterns/bridge)

[Bridge chercher.tech](https://chercher.tech/rust/bridge-design-pattern-rust)

- #### Decorator

... 

[Decorator sourcemaking.com](https://sourcemaking.com/design_patterns/decorator)

[Decorator refactoring.guru](https://refactoring.guru/ru/design-patterns/decorator)

- #### Composite,Facade 	

Спраятать за удобным интерфейсом сложное управление и последовательность действий
Он используется для компоновки объектов в древовидные структуры для представления иерархий,позволяя одинаково трактовать индивидуальные и составные объекты.

- #### DataMaper	

Посредник между постоянным хранилищем и данными в памяти( массив)
Цель паттерна в том,чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных.
В отличии от ActiveRecord где полностью отображается структура реаляционной базы на свойства классов
В связке с паттреном Repository который представляет слой над DataMaper получаем независимую друг от друга систему общения бизнес-логики с данными

Персистентность (т.е. минимизация подверженности изменениям ) архитектурного слоя поддрживает Repository за счет того что он берет на себя все изменения/новые требования бизнес-правил
 и в итоге обьекты DataMapers остаются неизменны

- #### ActiveRecord	

Схема Active Record — это подход к доступу к данным в базе данных. Таблица базы данных или представление обёрнуты в классы. 
Таким образом, объектный экземпляр привязан к единственной строке в таблице. После создания объекта новая строка будет добавляться к таблице на сохранение. 
Любой загруженный объект получает свою информацию от базы данных. Когда объект обновлён, соответствующая строка в таблице также будет обновлена. 
Класс обёртки реализует методы средства доступа или свойства для каждого столбца в таблице или представлении.
Нарушает принцип единственной ответственности (SRP) или нет ?

- #### Dependency injection DI

Для реализации слабосвязанной архитектуры. 
Для выноса из класса неявных зависимостей тремя способами(путем явной зависимости через конструктор,метод,интерфейс) для явной зависимости что бы была возможность подменить обьекты при тестировании.
Объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму
Чтобы получить более тестируемый, сопровождаемый и расширяемый код.
Реализуется через передачу обьекта в конструктор,метод,интерфейс

Внедрение зависимости позволяет переложить часть ответственности за какой-то функционал на другие объекты. 
Например если нам требуется нанять новый персонал, то мы можем не создавать свой отдел кадров, а внедрить зависимость от компании по подбору персонала, которая свою очередь по первому нашему требованию «нам нужен человек», будет либо сама работать как отдел кадров, либо же найдет другую компанию (при помощи «локатора служб»), которая предоставит данные услуги.
«Внедрение зависимости» позволяет перекладывать и взаимозаменять отдельные части компании без потери общей функциональности.

- #### Fasade	

Один класс, представляющий всю подсистему.

- #### Proxy	

Объект, представляющий другой объект

- #### Private Class Data	

Ограниченный доступ к средствам доступа / мутаторам.

- #### Flyweight	

Детализированный экземпляр, используемый для эффективного совместного использования.

- #### Service Locator	

Для реализации слабосвязанной архитектуры, чтобы получить хорошо тестируемый, сопровождаемый и расширяемый код. 
Паттерн Инъекция зависимостей (DI) и паттерн Локатор Служб — это реализация паттерна Инверсия управления (Inversion of Control, IoC)
Анти-паттерн так как нарушает принцип SOLID инверсии зависимости т.е. он избавляет другие классы от этого но сам зависим от конкретных классов.
В случае изменения данных зависимостей мы рискуем сломать функционал классов, которые их используют, вследствие чего затрудняется поддержка системы.

- #### Row Data Gateway (DataMaper) 

Предоставляет вам объекты, которые выглядят точно так же, как записи в вашей структуре записей, но доступны с помощью обычных механизмов вашего языка программирования. Все детали доступа к источникам данных скрыты за этим интерфейсом.

## <ins>Паттерны поведения</ins>

Эта группа паттернов позволяет структурировать подходы к обработке поведения и взаимодействия объектов. Проще говоря, как должны проходить процессы в которых существует несколько вариантов протекания событий.

- #### Command (Команда)	

**Команда** — это поведенческий паттерн проектирования, который превращает запросы в объекты, 
позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, 
а также поддерживать отмену операций.

Когда использовать паттерн команды:

- Очередь. Когда запросы необходимо обрабатывать в определенные моменты времени и в соответствии с различными триггерными ситуациями.

- Слои. Когда необходимо разделить клиента и поставщика услуг (инкапсуляция получателя, для вызывающего не важно какая команда будет послана)

- Когда возникает необходимость в функции отката для определенных операций

- Когда необходима история запросов

- Когда есть необходимость добавить новые команды

- При необходимости параметризации объектов по действию

Мы хотим, чтобы эти действия или команды выполнялись или вызывались в определенном порядке позже и в другое время. 
Эти команды также могут быть вызваны в результате какого-либо события. 
Например, когда пользователь нажимает кнопку или при получении пакета данных. 
Кроме того, эти команды могут быть отменены. 
Это может оказаться полезным для работы редактора. 
Возможно, нам захочется хранить журналы выполненных команд, чтобы можно было повторно применить изменения позже, если система выйдет из строя.

[Command refactoring.guru](https://refactoring.guru/ru/design-patterns/command)

[Command rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html)

- #### Command + Composite	

Компоновка команд в блоки

- #### Command + Composite + Chain Of Responsibilities

Компоновка команд в блоки и делегирование другим командам

- #### Interpreter	

Известен как Little (Small) Language, позволяет создать **свой язык** для гибкости и простоты использования пользователем

Design components:

Abstract Expression - объявляет операцию interpret(), которую переопределяют все узлы (терминальные и нетерминальные) в AST.
    класс абстрактного выражения определяет абстрактный интерфейс для языковых выражений. Он объявляет interpret()
    метод, определяющий логику интерпретации выражений.

Terminal Expression - (NumberExpression): реализует операцию interpret() для терминальных выражений.
    классы терминальных выражений представляют собой элементарные строительные блоки языка. Они реализуют интерфейс
    абстрактных выражений и обеспечивают логику интерпретации терминальных выражений.

Non-Terminal Expression - (AdditionExpression, SubtractionExpression, and MultiplicationExpression):
    реализует операцию interpret() для всех нетерминальных выражений.
    классы нетерминальных выражений представляют собой составные выражения, состоящие из нескольких подвыражений.
    Они также реализуют интерфейс абстрактных выражений и обеспечивают логику интерпретации составных выражений.

Context - содержит информацию, которая является глобальной для интерпретатора.
    класс контекста предоставляет любую необходимую информацию или состояние, необходимое для интерпретации выражений.
    Он сохраняет глобальную информацию, разделяемую между выражениями во время интерпретации.

Client - (ExpressionParser): строит (или предоставляет) AST, собранный из TerminalExpression и NonTerminalExpression.
    Клиент вызывает операцию interpret()

![Interpreter](https://github.com/Jekahome/Patterns/blob/main/Interpreter.png "Interpreter")

[Interpreter sourcemaking.com](https://sourcemaking.com/design_patterns/interpreter)

[Interpreter geeksforgeeks](https://www.geeksforgeeks.org/interpreter-design-pattern/)

[Interpreter medium.com](https://medium.com/@rajeshvelmani/understanding-language-interpretation-with-the-interpreter-design-pattern-in-java-b2a3969eaf9)

- #### Strategy	

Позволяет эффективно работать коду, благодаря наличию реализованных стратегий основываясь на входных данных.
Все стратегии реализуются по обшему интерфейсу и соответственно код становится гибким/взаимозаменяемым.
Это позволяет отказаться от использования переключателей и/или условных операторов.
К примеру выбор способа сортировки зависит от типа и размера данных, соответственно выбирая подходящий алгоритм мы используем паттерн стратегия.

Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к `Template Strategy`.

Одно из преимуществ использования `Template Strategy` заключается в том, что мы можем избавиться от ветвления `if/else`.
Достигается это за счет того, что `Client` "знает",
какой алгоритм он хочет использовать и передает объект алгоритма в конструктор класса - `Context`. 
Согласно `Singl responsibility` разделяем классы на подклассы.

Один из принципов SOLID: open/close - предполагает сущность открыта для расширения но закрыта для модификаций. Таким образом при надобности расширить
поведение сущности мы просто добавляем еще одну стратегию, вместо изменения кода сущности.

Мотивы
Программа должна обеспечивать различные варианты алгоритма или поведения
Нужно изменять поведение каждого экземпляра класса
Необходимо изменять поведение объектов на стадии выполнения
Введение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы


Эмпирические правила:

- `Template Strategy` похожа на `Template Method`, за исключением степени детализации.

- `Template State` похож на `Template Strategy`, за исключением своего намерения.

- `Template State, Strategy, Bridge` (и в некоторой степени `Template Adapter`) имеют схожие структуры решений. 
Все они разделяют элементы идиомы «handle/body». Они различаются по назначению – то есть решают разные задачи.

- `Template Strategy` имеет две разные реализации, первая похожа на `Template State`. 
Разница заключается во времени привязки (`Template Strategy` — это шаблон с однократной привязкой, тогда как `Template State` более динамичен).
Объекты стратегии часто становятся хорошими легковесами.

- `Template Strategy` позволяет вам изменить внутренности объекта. `Template Decorator` позволяет менять скин.
И `Template Strategy`, и `Template Decorator` могут применяться для изменения поведения конкретных классов. 
Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более удобным, а недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.

Состоит:

 - Strategy - абстрактная сущность 

 - ConcreteStrategy - конкретные реализации стратегии 

 - Context - содержит конкретную стратегию
 
 - Client - выбирает какую стратегию применять

[Strategy rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/strategy.html)

[Strategy sourcemaking.com](https://sourcemaking.com/design_patterns/strategy)

[Strategy refactoring.guru](https://refactoring.guru/ru/design-patterns/strategy)

[Strategy ru.wikipedia.org](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

- #### Visitor	

`Template Visitor` позволяет добавлять в программу новые операции, не изменяя разнородные классы объектов, 
над которыми эти операции могут выполняться.
(т.е. все струтуры или перечисления остаюся нетронутыми `...Industrial,Residential,Commercial,Build,LevelBuild`)

`Template Visitor` полезен везде, где вы хотите применить алгоритм к разнородным данным. 
Если данные однородны, просто применяем один метод. 
Использование объекта посетителя (а не функционального подхода) позволяет посетителю сохранять состояние и, 
таким образом, передавать информацию между узлами.

Т.е. в идеале мы бы могли имплементироваться от трейта и просто вызывая обший для всех метод решить свою задачу, но мы в силу каких-то
причин так не можем делать. 
Так-же, возможная причина, это неуместная логика в рамках этих структур или потенциальные изменения в новой требуемой логике.

`Template Fold` аналогичен `Template Visitor`, но создает новую версию посещенной структуры данных.

[Visitor refactoring.guru](https://refactoring.guru/ru/design-patterns/visitor)

[Visitor sourcemaking.com](https://sourcemaking.com/design_patterns/visitor)

[Visitor rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html)

[Visitor habr.com](https://habr.com/ru/articles/332042/)

- #### Observer (схож с Mediator)	

Наблюдатель за состоянием и уведомление подписчиков, реализует databinding

В основе шаблона Observer лежит принцип отсоединения клиентских элементов (наблюдателей) от центрального класса (субъекта). 
Наблюдатели должны быть проинформированы, когда происходят события, о которых знает субъект. 
В то же время мы не хотим, чтобы у субъекта бьла жестко закодированная связь с его классами-наблюдателями.                                                                                                         

Для реализации публикации/подписки на поведение объекта, всякий раз, когда объект «Subject»
меняет свое состояние, прикрепленные объекты «Observers» будут уведомлены.
Паттерн используется, чтобы сократить количество связанных напрямую объектов и вместо этого использует слабую связь (loose coupling).
 

- #### Delegation	 

Объект, вместо того чтобы выполнять одну из своих поставленных задач, поручает её связанному вспомогательному объекту.

- #### Iterator	

Возможность использовать перебор обьекта как массив

Используется в составных объектах. Предоставляет доступ к своим внутренним полям не раскрывая их структуру.

Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой. 
Это может быть ограничение доступа, сортировка или любая другая операция над множеством объектов.

- #### Mediator	

Центр упраляния классами связанных друг с другом снижая их связанность и не надо вызывать друг друга напрямую

Этот паттерн позволяет снизить связность множества компонентов, работающих совместно.
Объектам больше нет нужды вызывать друг друга напрямую. 
Это хорошая альтернатива Наблюдателю, если у вас есть “центр интеллекта” вроде контроллера (но не в смысле MVC)
Все компоненты (называемые «Коллеги») объединяются в интерфейс MediatorInterface.
Подписчики или объединенные компоненты делегируют управление медиатору.

- #### State	

В зависимости от состояния изменяется поведение

Состояние
   Инкапсулирует изменение поведения одних и тех же методов в зависимости от состояния объекта.
   Этот паттерн поможет изящным способом изменить поведение объекта во время выполнения
   не прибегая к большим монолитным условным операторам.
   Присутствует четкая последовательность состояний управляемая через контекст

- #### Specification	 

Строит правила на соответствие которых проверяются объекты

Спецификация (Specification)
   Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. 
   Композитный класс спецификация имеет один метод, называемый isSatisfiedBy, 
   который возвращает истину или ложь в зависимости от того, удовлетворяет ли данный объект спецификации.

- #### Memento (Хранитель)	

Хранитель Он обеспечивает возможность восстановления объекта до его предыдущего состояния
Хранить и восстанавливать снимок состояния объекта

- #### Chain Of Responsibilities 

(цепочка обязанностей) делегировать управление другим классом в нужном случае 

По сути это набор обработчиков, которые по очереди получают запрос, а затем решают обрабатывать его или нет. 
Если запрос не обработан, то он передается дальше по цепочке. 
Если же он обработан, то паттерн сам решает передавать его дальше или нет.
middleware

- #### Template method	

Шаблонный Метод  Изолирует алгоритм/логику в классы наследники переопределяя родителя 
Устраняет дублирование кода,
Задает скелет алгоритма в методе где вызываются абстрактные методы субклассов

Идея состоит в том, чтобы позволить наследникам абстрактного
шаблона переопределить поведение алгоритмов родителя.
  
Это простой способ изолировать логику в конкретные классы и уменьшить копипаст,
поэтому вы повсеместно встретите его в том или ином виде.

- #### Command invoker	 

Command и receiver исполнитель назначение команды и выполнение ее исполнителем


### <ins>Шаблоны баз данных</ins>

Шаблоны баз данных, сохранять и извлекать данные из баз данных и устанавливать соответствие между объектами базы данных и приложения.

- #### Data Mapper 	

Преобразователь Данных — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже загружено и используется для логической обработки). 
Цель паттерна в том, чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных. 
Слой состоит из одного или более mapper-а (или объектов доступа к данным), отвечающих за передачу данных. 
Реализации mapper-ов различаются по назначению. 
Общие mapper-ы могут обрабатывать всевозоможные типы сущностей доменов, а выделенные mapper-ы будет обрабатывать один или несколько конкретных типов.

- #### Identity Map	

Обеспечивает однократную загрузку объекта, сохраняя данные об объекте в карте соответствия. 
При обращении к объектам, ищет их в карте соответсвия.
Паттерн Identity Map (Карта присутствия / Карта соответствия) хранит записи о всех объектах, которые были считаны из БД за время выполнения одного действия. 
Когда происходит обращение к объекту, проверяется карта соответствия (присутствия), чтобы узнать, загружен ли объект.

- ####  Lazy Load 

Загрузка данных по мере необходимости


[Rust patterns](https://rust-unofficial.github.io/patterns/)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

## Слоеная архитектура 

...

## Принципы DDD 

...


### CQRS-ES

Разделение команд-запросов (CQS) «Функции не должны вызывать абстрактные побочные эффекты... только команды (процедуры) могут вызывать побочные эффекты». - Бертран Мейер: Объектно-ориентированное создание программного обеспечения

CQRS — это стиль архитектуры, в котором операции чтения отделены от операций записи. Использовал с паттерном command
 Подход сформулировал Грег Янг на основе принципа CQS, предложенного Бертраном Мейером. 
Чаще всего (но не всегда) CQRS реализуется в ограниченных контекстах (bounded context) приложений, проектируемых на основе DDD.
 Одна из естественных причин развития CQRS — не симметричное распределение нагрузки и сложности бизнес-логики на read и write — подсистемы Большинство бизнес-правил и сложных проверок находится во write — подсистеме. 

--------------
 
[Rust Design Patterns](https://rust-unofficial.github.io/patterns/)

[Rust Design Patterns rust-unofficial](https://github.com/rust-unofficial/patterns)

[Rust Design Patterns refactoring.guru](https://refactoring.guru/ru/design-patterns/rust)

### ООП паттерны

[Rust Design Patterns](https://chercher.tech/rust/observer-design-pattern-rust)

[Паттерны проектирования](http://design-pattern.ru/patterns/)

[Каталог шаблонов архитектуры корпоративных приложений](https://martinfowler.com/eaaCatalog/index.html)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

[Что такое анти-паттерны?](https://habr.com/ru/articles/59005/)


### DesignPatternsPHP

[DesignPatternsPHP 1](https://designpatternsphp.readthedocs.io/ru/latest/index.html)

[DesignPatternsPHP github](https://github.com/domnikl/DesignPatternsPHP)

[DesignPatternsPHP 2](https://dron.by/)

[«Паттерны» функционального программирования](https://habr.com/ru/articles/337880/)

```bash
Куда складывать:
- Google Диск Exel Manual/Rust(Patterns/Algorithms)
- Google Диск Exel Manual/Patterns
- GitHub Jekahome/Pattrens

Источники:
- книги ../DesignPatterns_AndriyBuday
- книги ../Design-Patterns.md
- книги ../Разработка интерфейсов.паттерны проектирования.Дженифер Тидвелл
- книги ../Head_First_Паттерны_проектирования_2022_Эрик_Фримен,_Элизабет_Робсон
- код ../Patterns_Others_lang
- код ../Patterns_Rust_PHP_TypeScript
```

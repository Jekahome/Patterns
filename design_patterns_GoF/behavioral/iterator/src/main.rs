#![allow(unused_imports)]

/*

`Pattern Iteratot` - Предоставьте способ последовательного доступа к элементам агрегатного объекта, не раскрывая его базовое представление.

Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой.
Это может быть ограничение доступа, сортировка или любая другая операция над множеством объектов.

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.

Аналогия
Вы планируете полететь в Рим и обойти все достопримечательности за пару дней.
Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.
Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции.
Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.

Проблема
Также, возможный способ применения, когда вы используете экзотическую коллекцию данных т.е. не тривиально организованные данные.
Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину,
 но завтра потребуется возможность перемещаться по дереву в ширину.
Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, которая заключается в эффективном хранении данных.
Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.

Проблема
Необходимо «абстрагировать» обход совершенно разных структур данных, чтобы можно было определить алгоритмы,
способные прозрачно взаимодействовать с каждой из них.

Агрегированный объект, такой как список, должен давать вам возможность доступа к его элементам, не раскрывая его внутреннюю структуру.
Более того, вы можете захотеть перемещаться по списку разными способами, в зависимости от того, чего вам нужно достичь.
Но вы, вероятно, не делаете этого. хотите раздуть интерфейс списка операциями для разных обходов, даже если вы можете предвидеть те,
которые вам потребуются. Вам также может потребоваться иметь более одного ожидающего обхода в одном и том же списке».
Кроме того, может оказаться полезным предоставление единого интерфейса для обхода многих типов агрегатных объектов (т. е. полиморфной итерации).

Абстракция `Iterator` является фундаментальной для новой технологии, называемой «обобщенным программированием».
Эта стратегия стремится явно отделить понятие «алгоритм» от понятия «структура данных».

Эмпирические правила
- Абстрактное синтаксическое дерево `Pattern Interpreter` является составным (поэтому также применимы `Pattern Iteratot` и `Pattern Visitor`).

- `Pattern Memento` часто используется вместе с `Pattern Iteratot`. Итератор может использовать Memento для фиксации состояния итерации. Итератор хранит Memento внутри себя.

В Rust итераторы ленивы, то есть они не действуют, пока вы не вызовете методы, которые используют итератор для его использования.
*/
use std::iter::{IntoIterator, Iterator};
use words::WordsCollection2;

pub mod words {
    pub struct WordsCollection2 {
        items: Vec<String>,
        prev: usize,
        reverse: bool,
    }
    impl WordsCollection2 {
        pub fn new(items: Vec<String>, reverse: bool) -> Self {
            if !reverse {
                return Self {
                    items,
                    prev: 0,
                    reverse,
                };
            }
            let prev = items.len();
            Self {
                items,
                prev,
                reverse,
            }
        }
    }

    impl Iterator for WordsCollection2 {
        type Item = String;
        fn next(&mut self) -> Option<String> {
            if self.reverse {
                if self.prev > 0 {
                    self.prev -= 1;
                    return Some(self.items[self.prev].clone());
                }
                return None;
            } else {
                if self.prev < self.items.len() {
                    self.prev += 1;
                    return Some(self.items[self.prev - 1].clone());
                }
                return None;
            }
        }
    }
}

struct WordsCollection {
    items: Vec<String>,
}

impl IntoIterator for WordsCollection {
    type Item = String;
    type IntoIter = ::std::vec::IntoIter<String>;

    fn into_iter(self) -> Self::IntoIter {
        self.items.into_iter()
    }
}

// cargo run --bin iterator
fn main() {
    let w = WordsCollection {
        items: vec!["First".into(), "Second".into(), "Third".into()],
    };
    for i in w {
        println!("{}", i);
    }

    let w = WordsCollection2::new(vec!["First".into(), "Second".into(), "Third".into()], true);
    for i in w {
        println!("{}", i);
    }
}


# Clean Code Principles

- Be Consistent

- Meaningful names over Comments

- Indentation and Code Style

- Keep methods, classes, file small

- Pure functions

- Minimize cyclomatic complexity

- Avoid passing nulls, booleans

- Keep framework code distant

- Use correct constructs

- Tests should be fast and independent

- Use meaningful names

- Organize code by the actor it belongs to

- Command Query Separation

- Keep it simple and refactor often

# Programming Paradigms

**Парадигма** - это стиль написания и использования средств языка, могут совмешаться в зыках (мкльтипарадигма)

Парадигма **Императивное программирование** — последовательность **КОМАНД** которые последовательно выполняются, как магинный код. Акцент на подход **КАК** решать задачу в отличии от декларативного. Все языке являются ииперативными. 

Парадигма **Процедурное программирование** —  чтобы не дублировать одни и те же **КОМАНД**ы их можно использовать повторно через процедуры(есть входные параметры и нет выходных)/функции(есть входные и выходные параметры).Почти все языке являются процедурными. 

Парадигма **Функциональное программирование** —  (подкатегория декларативного т.е. акцент на описание спецификации **ЧТО** мы хотим).Более понятен чем императивеая парадигма.Орерирует оенивыми замыканиями, выполняющимися когда из вызовут.
Конструировать программу с помошью фукций в которых выход одной фукций является входом для другой фукций, и комбинируя ф-ции решать задачу.
Поэтому в функциональном прогрпммирование есть ограничение на функции они должны быть чистыми (не изменяет состояние, принимает аргументы и возврашает результат, код функции не выходит за ее собственные пределы). 
В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций. Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.
Список ф-циональных языков: `LISP, HASKELL, ERLANG, CLOJURE, #F`

Несмотря на то, что исторически первым был применен декларативный подход в программировании, первые языки программирования компьютеров (машинный, ассемблер, фортран, алгол, кобол) были императивными в силу простоты подхода.
Парадигма Декларативное программирование — задаётся спецификация решения задачи:т.е. акцент на **ЧТО** мы хотим, описывается, что представляет собой проблема и ожидаемый результат, но без описания способа КАК достичь этого результата. Пример - `SQL`.
Зачастую декларативные программы не используют понятия состояния и, в частности, не содержат переменных и операторов присваивания, обеспечивая ссылочную прозрачность. 
К подвидам декларативного программирования часто относят и функциональное программирование. 

Парадигма **Структурное программирование** — появилась необходимость в абстрациях, из-за сложности программ. Парадигма следует особому струтурированию кода:последовательность, ветвления `if/else`, цикл `while`, процедуры и функции, блоки кода. Представитель - язык `C,Go,C#`

Парадигма **Обьектно-ориентированное программирование (ООП)** — появилась необходимость в абстрациях, из-за сложности программ. Оперирует понятиями класса и обьекта,а также инкапсуляция(упаковка),наследование(расширение),полиморфизм(повторное использование).Дает гибкость в структурировании программ. Это архитектура приложения, способ моделирования предметной области. При котором используется разделение на сущности по принципу недопустить возможность ввести сущность в некорректное состояния.

# Что такое паттерны, зачем и почему?

Способ решения часто встречающихся задач. 
Они делают наше программное обеспечение более модульным, удобным в сопровождении и расширяемым. 
Более того, эти шаблоны предоставляют разработчикам общий язык, что делает их отличным инструментом для эффективного общения при решении проблем в группах.

Лучшее понимание паттернов и алгоритмов, повышает гибкость мышления и качество конечного продукта.
Глобально, Мир станет совершеннее, если перестать **плодить** мусор. Следует различать **создание** мусора в процессе разработки с последующим его рефакторингом, и конечный результат в виде мусора (**плодить**), так как он остается на обозрение пользователей.

### Подходят ли ООП паттерны для Rust?

Rust - статически типизированный язык системного уровня программирования, с парадигмой функционального и процедурного стиля. Используется не только для системного программирования интрументария но и для прикладных программ пользователю, WEB бэкенд и фронтенд, игр, встроенных систем микроконтроллеров.

В информатике функциональное программирование — это парадигма программирования, в которой программы создаются путем применения и составления функций.
Это парадигма декларативного программирования, в которой определения функций представляют собой деревья выражений, каждое из которых возвращает значение, а не последовательность императивных операторов, которые изменяют состояние программы.

Парадигмы - это стили написания кода, в Rust есть возможности структурировать код в функциональном стиле используя методы итератора,вектора или собственными силами соблюдая правила:
неизменяемость данных,чистые функции(не имеют побочных эффектов),композиция функций(объединения нескольких функций в одну),функции высшего порядка(принимают другие функции в качестве аргументов или возвращают),отсутвие операций присвоения для сохранения промежуточных результатов вызовов функций.

Так же сможем придерживаться процедурного стиля, компоновать код для повторного использования с применением присвоения для сохранением промежуточных данных между вызовами процедур. 
И это не запрещает нам структурировать код в ООП стиле (нет наследования данных и реализаций, только интерфейсов через super-trait, есть инкапсуляция c помошью mod и есть полиморфизм c помощью trait-object и параметрический полиморфизм дженериков и ограничение трейтами). 
Сдедовательно, только наши цели (предметная область) и ограничения или особенности языка (идиомы), задают каким образом использовать паттерны.  

**Императив**
```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

**Декларативный**
```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
// `fold` это функция, которая составляет функции.
```
Помните, что в декларативных программах мы описываем, **ЧТО** делать, а не **КАК** это делать. 

Также благодаря `static dispatch` мы можем вынести потенциальные ошибки использования типов на этап компиляции кода.  
Система типов Rust может превратить многие виды проблем программирования в проблемы `static dispatch`. 
Это одно из самых больших преимуществ при выборе функционального языка, и оно имеет решающее значение для многих гарантий времени компиляции Rust.
В Rust параметр универсального типа создает то, что в функциональных языках называется «**ограничением класса типа**».
Это называется **мономорфизацией**, когда разные типы создаются из полиморфного кода.

**Альтернативы**

Если типу требуется «раздельнный API» из-за конструкции или частичной инициализации, вместо этого рассмотрите **Builder Pattern**.

Если API между типами не меняется — меняется только поведение — тогда лучше использовать **Strategy Pattern** 
(в Rust нет необходимости в шаблоне стратегии , потому что мы можем просто использовать трейты :thinking:).

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/_img/Rust%20idioms.png "Rust idioms")

Рекомендации, которым следует следовать при кодировании. Это согласованные нормы общества. Нарушать их следует только в том случае, если у вас есть для этого веская причина.

- Type safety (Newtype, Typestates) 

- Mem replace (hook lifetime)

- Bound impl (ограничение поведения)

- Generic in type out (абстракция аргументов)

- Exhaustivity (проверка на полноту вариантов)

- Sealing (запечатывание реализации)

- Конструктор с помощью ф-ции `new` и конструктор по умолчанию `Default`

- Динамическая диспетчеризация на стеке

- Передача переменных в замыкание 

- Временная мутабельность

- Возвращать использованный аргумент при ошибке

[Rust idioms rust-incubator](https://github.com/instrumentisto/rust-incubator/tree/main/2_idioms)

[Rust idioms rust-unofficial](https://rust-unofficial.github.io/patterns/idioms/index.html)

[Rust idioms rust-unofficial github](https://github.com/Jekahome/RustDesignPatterns/tree/main/src/idioms)

[Реализация конечного автомата (переходы между состояниями)](https://hoverbear.org/blog/rust-state-machine-pattern/)

[шаблон Состояние](https://doc.rust-lang.ru/book/ch17-03-oo-design-patterns.html)

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/_img/Anti%20patterns.png "Anti patterns")

Методы решения распространенных проблем при кодировании. Однако, хотя шаблоны проектирования дают нам преимущества, антишаблоны создают больше проблем.

- Клонирование для проверки заимствований (borrow checker)

- Использование подавление предупреждений компилятора при сборке

- Неправильное использование трейта `Deref`

- Золотой молоток (Golden hammer)

- Мягкое кодирование (Soft code)/ Жёсткое кодирование (Hard code)

[Anti patterns sourcemaking.com](https://sourcemaking.com/antipatterns)

- [Антипаттерны разработки программного обеспечения](https://sourcemaking.com/antipatterns/software-development-antipatterns)

- [Антипаттерны архитектуры программного обеспечения](https://sourcemaking.com/antipatterns/software-architecture-antipatterns)

- [Управление программными проектами](https://sourcemaking.com/antipatterns/software-project-management-antipatterns)

![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/_img/Design%20principles.png "Design principles")

# Design principles: SOLID

Принцип единой ответственности (SRP): класс должен иметь только одну ответственность, то есть только изменения в одной части спецификации программного обеспечения должны иметь возможность повлиять на спецификацию класса.

Принцип открытости/закрытости (OCP): «Программные объекты… должны быть открыты для расширения, но закрыты для модификации».

Принцип замены Лискова (LSP): «Объекты в программе должны быть заменены экземплярами их подтипов без изменения корректности этой программы».

Принцип разделения интерфейсов (ISP): «Интерфейс отвечающий за одну область задач лучше, чем один интерфейс общего назначения».

Принцип инверсии зависимостей (DIP): нужно «зависеть от абстракций, а не от конкретики».

## Design principles: KISS

Большинство систем работают лучше всего, если их сохранять простыми, а не усложнять; следовательно, простота должна быть ключевой целью проектирования, и следует избегать ненужной сложности.
Простота кода – превыше всего, потому что простой код – наиболее понятный.
Если вы используете паттерн проектирования там, где нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код. 
Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.

Моя интерпритация KISS - соблюдать необходимые рекомендации разработки проекта чтобы, в момент когда проект достигнет немалых масштабов и потребуется вносить изменения, то разработчик мог это сделать малыми силами. Для этого, помимо использования общеизвестных паттернов и идиом технологии/языка если они уместны, должна быть в наличии документация, тесты, необходимые комментарии, ссылки на источники, само собой разумеется SOLID, содержательные имена. К тому же, архитектура приложения должна предусматривать внесение вероятных изменений.  

[KISS — принцип проектирования, содержащий все остальные принципы проектирования](https://habr.com/ru/articles/249639/)

## Design principles: DRY

"**Не повторяйте себя.**"

Короче говоря, всякий раз, когда вы ловите себя на том, что пишете один и тот же код дважды, у вас есть возможность стать более эффективным.
Следование этому принципу означает, что ваша цель — сократить количество повторяющихся шаблонов и дублирования кода и логики в пользу модульного кода, на который можно ссылаться т.е. использовать повторно.

В книге «Программист-прагматик» мы можем увидеть такое определение DRY:
«Каждая часть знаний должна иметь единственное, однозначное и авторитетное представление в системе»

Это означает, что у вас не должно быть дублированного кода. 
Легче поддерживать код, который находится только в одном месте, потому что если вам нужно что-то изменить в коде, вам просто нужно изменить это в одном месте. 
Кроме того, если у вас есть один и тот же код в двух или более местах, вероятность того, что этот код со временем станет другим, высока, и когда это произойдет, это станет простым способом внести ошибки в вашу систему.
Дублированный код также делает код более сложным и неоправданно большим.

## Design principles: YAGNI 

"**Тебе это не понадобится**"

Это означает, что вам не следует реализовывать функциональность только потому, что вы думаете, что она вам когда-нибудь понадобится, а реализовывать ее только тогда, когда она вам действительно понадобится. Поступая так, вы избежите траты времени на реализации, которые даже не были необходимы и, возможно, никогда не будут использоваться.

[Design principles](https://rust-unofficial.github.io/patterns/additional_resources/design-principles.html)

[dry-kiss-yagni-principles](https://henriquesd.medium.com/dry-kiss-yagni-principles-1ce09d9c601f)


![This is an alt text.](https://github.com/Jekahome/Patterns/blob/main/_img/Design%20patterns.png "Design patterns")

Методы решения распространенных проблем при кодировании.

# Gangs of Four (GoF) Design Patterns

Шаблоны проектирования `GoF` делятся на три категории:

- **Порождающие** паттерны связанны с созданием объекта. `Singleton, Builder, Factory, Fabric Method, Prototype, Fold`

- **Структурные** паттерны связаны со структурой классов, такой как наследование и композиция. `Adapter, Bridge, Composite, Decorator, Facade, Proxy, Flyweight`

- **Поведенческие** паттерны обеспечивают решение для лучшего взаимодействия между объектами, обеспечения потери связнности и гибкости для легкого расширения в будущем. `Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor`

## <ins>Порождающие паттерны</ins>

Паттерны которые создают новые объекты, или позволяют получить доступ к уже существующим. 
То есть те шаблоны, по которым можно создать новый автомобиль и как это лучше сделать.

- ## Builder	

Создайте объект с помощью вызовов помощника-строителя.
`Pattern Builder` — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
`Pattern Builder` даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
`Pattern Builder` особенно подходит, когда при построении T есть побочные эффекты, такие как создание потока или запуск процесса.
Полезно, когда в противном случае вам потребовалось бы много конструкторов или когда конструкция имеет побочные эффекты.

Преимущества
Отделяет методы построения от других методов.
Предотвращает распространение конструкторов.
Может использоваться для однострочной инициализации, а также для более сложной конструкции.

Этот шаблон чаще встречается в Rust (и для более простых объектов), чем во многих других языках, поскольку в Rust отсутствует перегрузка. 
Поскольку у вас может быть только один метод с заданным именем, иметь несколько конструкторов в Rust менее удобно, чем в C++, Java или других.

Этот шаблон часто используется там, где объект-строитель полезен сам по себе, а не просто является строителем. 
Например, см [std::process::Command](https://doc.rust-lang.org/std/process/struct.Command.html)
```
    Command::new("sh")
            .arg("-c")
            .arg("echo hello")
            .output()
            .expect("failed to execute process")

```

[Builder rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html)

[Builder](https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)

- ## Fold

Создание новой коллекции посредством изменения элементов применив соответсвующий реализованный алгоритм.

`Pattern Fold` аналогичен `Pattern Visitor`, но создает новую версию посещенной структуры данных.
Они разделяют концепцию обхода структуры данных, выполняя операцию на каждом узле. 
Однако посетитель не создает новую структуру данных и не использует старую.

**Мотивация**

Обычно требуется отобразить структуру данных, выполнив некоторую операцию над каждым узлом структуры. 
Для простых операций с простыми структурами данных это можно сделать с помощью `Iterator::map`. 
Для более сложных операций, возможно, когда более ранние узлы могут повлиять на операцию на более поздних 
узлах или где итерация по структуре данных нетривиальна, использование шаблона свертывания является более подходящим.

Как и `Pattern Visitor`, `Pattern Fold` позволяет нам отделить обход структуры данных от операций, выполняемых с каждым узлом.


**Обсуждение**

Такое отображение структур данных распространено в функциональных языках. 
В объектно-ориентированных языках более распространено изменение структуры данных на месте. 
«Функциональный» подход распространен в Rust, в основном из-за предпочтения неизменяемости. 
Использование новых структур данных вместо изменения старых в большинстве случаев упрощает анализ кода.

Компромисс между эффективностью и возможностью повторного использования можно изменить, изменив способ приема узлов методами fold_*.

В приведенном выше примере мы работаем с Boxуказателями. Поскольку они владеют исключительно своими данными, 
исходную копию структуры данных нельзя использовать повторно. 
С другой стороны, если узел не изменяется, его повторное использование очень эффективно.

Если бы нам пришлось работать с заимствованными ссылками, исходную структуру данных можно было бы использовать повторно; 
однако узел необходимо клонировать, даже если он не изменился, что может быть дорогостоящим.

Использование указателя с подсчетом ссылок дает лучшее из обоих миров: мы можем повторно использовать исходную структуру данных, 
и нам не нужно клонировать неизмененные узлы. 
Однако они менее эргономичны в использовании и означают, что структуры данных не могут быть изменены.

У итераторов есть fold метод, однако он сворачивает структуру данных в значение, а не в новую структуру данных. 

[Fold rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/creational/fold.html)

- ## Abstract factory	

Его основное назначение - предоставить интерфейс для создания семейства взаимосвязанных объектов, не специфицируя их классы.
Используется в тех случаях, когда необходимо изменять поведение системы,
варьируя создаваемыми объектами, при этом сохраняя интерфейсы. Он позволяет создавать группы взаимосвязанных объектов,
реализующих общее поведение. 
Например, в зависимости от конкретных условий

- ## Factory method	
 
`Factory Method`
фабрике заранее неизвестно, объекты каких подклассов ему нужно создавать.
фабрика проектируется так, чтобы объекты, которые она создаёт, определялись ее подклассами.
т.е. делегирует свои обязанности одному из нескольких вспомогательных подклассов.

 
`Factory Method` избавляют проектировщика от необходимости встраивать в код классы выаолняющие создание кокнретных реализаций.
Также используется когда клиент не имеет прав или доступа или к деталям реализации классов.(инкапсуляция создания конкретных типов обьектов)
Фабричный метод используется, когда продуктам не нужно знать, как они созданы.

**Применимость**

- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
  `Factory Method` отделяет код производства продуктов от остального кода, который эти продукты использует.

- Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
  Т.е. `Factory Method` может еще управлять логикой создания обьектов, взаимодействуя с хранилищем `Redis,Json,...` этих обьектов.


**Отношения с другими паттернами**

Многие архитектуры начинаются с применения `Factory Method` (более простого и расширяемого через подклассы) 
и эволюционируют в сторону `Abstract Factory`, `Pattern Prototype` или `Pattern Builder` (более гибких, но и более сложных).

Классы `Abstract Factory` чаще всего реализуются с помощью `Factory Method`, хотя они могут быть построены и на основе `Pattern Prototype`.

[Factory method refactoring.guru](https://refactoring.guru/ru/design-patterns/factory-method)

[Factory method sourcemaking.com](https://sourcemaking.com/design_patterns/factory_method)

[Factory method chercher.tech](https://chercher.tech/rust/factory-design-pattern-rust)

- ## Prototype	

`Pattern Prototype` инкапсуляция создания клона

Проблема
У вас есть объект, который нужно скопировать. 
Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.
Но у нас может не быть доступа к приватных полям. И копирующий код становиться жество зависим от конкретного копируемого класса.

`Pattern Prototype` хочет что бы обьекты создавали свои копии самостоятельно и использовали эдиный интерфейс `method clone()`
Объект, который копируют, называется прототипом (откуда и название паттерна)
Также есть место для инкапсуляции логики создания клона

Если создание объекта требует много времени и средств, и у вас уже есть наиболее похожий экземпляр объекта, 
тогда вы клонируете уже приготовленный с его текущим состоянием.

Если вам нужна глубокая копия, вы можете использовать сериализацию в качестве хитрости, чтобы выполнить глубокую копию. 

[Prototype refactoring.guru](https://refactoring.guru/ru/design-patterns/prototype)

[Prototype chercher.tech](https://chercher.tech/rust/prototype-design-pattern-rust)

- ## Singelton	

`Pattern Singleton` (Одиночка) применяется в том случае, когда какой-либо класс может иметь только один экземпляр (или не иметь ни одного) и легко доступен из глобальной видимости.
 
`Pattern Singleton` нарушает принцип единственной ответственности класса (SRP), так как он доступен глобально для различных частей программы следовательно есть вероятность изменения в одной из частей.

`Pattern Singleton` решает сразу две проблемы:

1.Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.

Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.

Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.

2.Предоставляет глобальную точку доступа. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту.  

Недостатки:

Модульное тестирование клиентского кода Singleton может быть затруднено, поскольку многие среды тестирования полагаются на наследование при создании фиктивных объектов. Поскольку конструктор класса-одиночки является закрытым и переопределение статических методов невозможно в большинстве языков, вам нужно будет придумать творческий способ имитировать синглтон. Или просто не пишите тесты. Или не используйте шаблон Singleton.

Требует специальной обработки в многопоточной среде

[Singleton refactoring.guru](https://refactoring.guru/design-patterns/singleton/rust/example#example-1)

- ## Object Pool Pattern	

Этот тип шаблона проектирования предоставляет метод повторного использования инициализированных объектов вместо создания новых 
Это позволяет вызвать определенный объект из пула для использования в течение определенного периода времени, 
а затем вернуть его обратно в пул после выполнения задания. 
Во время отсутствия этого объекта никакие другие компоненты не могут использовать его, пока он не будет возвращен обратно в пул.


## <ins>Структурирующие паттерны</ins>

Данные паттерны помогают внести порядок и научить разные объекты более правильно взаимодействовать друг с другом.

- ## Adapter	

`Pattern Adapter` работает как мост между двумя несовместимыми интерфейсами. 
Эту стратегию можно реализовать с помощью наследования, с помощью агрегации, или композиции, то есть делегирования работы другим объектам.
`Pattern Adapter` делает два несовместимых интерфейса совместимыми без изменения их существующего кода позволяя им работать вместе.
Adapter это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. 
Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. 

Это работает так:
1. `Pattern Adapter` имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. `Pattern Adapter` получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.


Применимость
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
- `Pattern Adapter` позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

**Отношения с другими паттернами**

`Pattern Brige` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. 
`Pattern Adapter` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
`Pattern Adapter` заставляет вещи работать после того, как они были спроектированы; `Pattern Brige` заставляет их работать изначально.

`Pattern Facade` задаёт новый интерфейс, тогда как `Pattern Adapter` повторно использует старый. 
`Pattern Adapter` оборачивает только один класс, а `Pattern Facade` оборачивает целую подсистему. 
Кроме того, `Pattern Adapter` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

`Pattern Adapter` предоставляет другой интерфейс для своего объекта. 
`Pattern Proxy` предоставляет тот же интерфейс. 
`Pattern Decorator` предоставляет улучшенный интерфейс.

`Pattern Adapter` предназначен для изменения интерфейса существующего объекта. 
`Pattern Decorator` улучшает другой объект, не меняя его интерфейс. 
Таким образом, декоратор более прозрачен для приложения, чем адаптер. 
Как следствие, `Pattern Decorator` поддерживает рекурсивную композицию, что невозможно при использовании чистых адаптеров.

![Adapter](https://github.com/Jekahome/Patterns/blob/main/_img/Adapter.png "Adapter")

[Adapter sourcemaking.com](https://sourcemaking.com/design_patterns/adapter)

[Adapter refactoring.guru](https://refactoring.guru/ru/design-patterns/adapter)

- ## Bridge

`Pattern Brige` - отделение интерфейса (группа поведений) от реализации (конкретное поведение из группы)

`Pattern Brige` используется, чтобы избежать увеличения количества подклассов, к которому в конечном итоге могут привести механизмы наследования. 
Итак, если у вас есть, скажем, 2 ортогональные обязанности, то вместо создания 2**2 подклассов вы используете композицию для объединения этих обязанностей.

Учитывая, что любое изменение, внесенное в абстракцию, повлияет на все классы, которые ее реализуют, 
`Pattern Brige` предлагает добавить **новый уровень абстракции** между обоими элементами, который позволяет разрабатывать каждый из них независимо. 


**Отношения с другими паттернами**

Основное различие между `Pattern Brige` и `Pattern Adapter` заключается в том, что `Pattern Adapter` используется 
для унификации уже существующих интерфейсов, а `Pattern Brige` используется, когда есть подозрение, что реализация интерфейса со временем изменится.
Т.е. своевременное использование `Pattern Brige` избавит нас от необходимости внедрять `Pattern Adapter`

Bridge Before:

![BridgeBefore](https://github.com/Jekahome/Patterns/blob/main/_img/BridgeBefore.png "BridgeBefore")

Bridge After:

![BridgeAfter](https://github.com/Jekahome/Patterns/blob/main/_img/BridgeAfter.png "BridgeAfter")


[Bridge](http://dron.by/post/pattern-proektirovaniya-bridge-most-na-php.html)

[Bridge sourcemaking.com](https://sourcemaking.com/design_patterns/bridge)

[Bridge refactoring.guru](https://refactoring.guru/ru/design-patterns/bridge)

[Bridge chercher.tech](https://chercher.tech/rust/bridge-design-pattern-rust)

- ## Decorator

`Pattern Decorator` (обёртка) - суть работы паттерна заключается в "оборачивании" готового объекта новым "функционалом", 
при этом весь оригинальный интерфейс объекта остается доступным (декоратор переадресует все запросы объекту). 
Смысл заключается в том, чтобы можно было безболезненно комбинировать различные декораторы в произвольном порядке, навешивая их на различные объекты. 

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. 
Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

**Аналогия**
Уличный аниматор наряжается создавая образ из различных аксессуаров - макияж, одежда, больщие уши, перчатки, обувь, головной убор, кегли, трость, ....
Акссесуары - это все декораторы, комбинируй в любой последовательности

Поскольку этот шаблон решает проблему динамического добавления функций во время выполнения, 
он решает проблему сложного требования к созданию подклассов при расширении функциональности базового класса.

Если есть требования четкой последовательности накидывания поведения то стоит рассмотреть вариации `Pattern Builder` или `Pattern Strategy`

**Эмпирические правила**

- Адаптер предоставляет другой интерфейс для своего объекта. Прокси предоставляет тот же интерфейс. Декоратор предоставляет улучшенный интерфейс.

- Адаптер меняет интерфейс объекта, Декоратор расширяет возможности объекта. Таким образом, Decorator становится более прозрачным для клиента. 
Как следствие, Decorator поддерживает рекурсивную композицию, что невозможно при использовании чистых адаптеров.

- Composite и Decorator имеют схожие структурные диаграммы, отражающие тот факт, что оба используют рекурсивную композицию для организации н
еограниченного количества объектов.

- Декоратор можно рассматривать как вырожденный композит, содержащий только один компонент. 
Однако декоратор добавляет дополнительные обязанности — он не предназначен для агрегации объектов.

- Декоратор предназначен для того, чтобы вы могли добавлять обязанности к объектам без создания подклассов. 
Основное внимание Composite уделяется не украшению, а репрезентации. Эти намерения различны, но дополняют друг друга. 
Следовательно, Composite и Decorator часто используются совместно.

- Composite может использовать цепочку ответственности, чтобы позволить компонентам получать доступ к глобальным свойствам через своего родителя. 
Он также может использовать Decorator для переопределения этих свойств частей композиции.

- Декоратор и Прокси имеют разные цели, но схожую структуру. 
Оба описывают, как обеспечить уровень косвенности к другому объекту, и реализации сохраняют ссылку на объект, которому они перенаправляют запросы.

- Декоратор позволяет изменить внешний вид объекта. Стратегия позволяет вам изменить внутренности.

**Пример**
Построить конструктор фильтров для input полей формы. Помимо множества типов полей, есть еще правила валидации
Так, накидывая различные декораторы на input, мы получаем желаемый результат

**Пример**
Приложение оборачивает класс данных в шифрующую и сжимающую обёртки, которые при чтении выдают оригинальные данные, а при записи — зашифрованные и сжатые.


![Decorator](https://github.com/Jekahome/Patterns/blob/main/_img/Decorator.jpg "Decorator")

[Decorator chercher.tech](https://chercher.tech/rust/decorator-design-pattern-rust)

[Decorator sourcemaking.com](https://sourcemaking.com/design_patterns/decorator)

[Decorator refactoring.guru](https://refactoring.guru/ru/design-patterns/decorator)


- ## Facade	

`Pattern Facade` скрывает сложности системы и предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

Оберните сложную подсистему более простым интерфейсом.
Один класс Facade, представляющий всю подсистему. 

Объект Facade должен быть довольно простым защитником или посредником. Он не должен становиться всезнающим оракулом или объектом «бога».

**Проблема**
Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. 
Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.
В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. 
Такой код довольно сложно понимать и поддерживать.

`Pattern Facade` может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. 
Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

`Pattern Facade` полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

Аналогия
Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. 
Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

**Эмпирические правила**

- `Pattern Facade` задаёт новый интерфейс, тогда как `Pattern Adapter` повторно использует старый. 
`Pattern Adapter` оборачивает только один класс, а `Pattern Facade` оборачивает целую подсистему. 
Кроме того, `Pattern Adapter` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

- Abstract Factory может быть использована вместо `Pattern Facade` для того, чтобы скрыть платформо-зависимые классы.

- Объекты Facade часто являются синглтонами, поскольку требуется только один объект Facade.

![Facade](https://github.com/Jekahome/Patterns/blob/main/_img/Facade.png "Facade")

[Facade refactoring.guru](https://refactoring.guru/ru/design-patterns/facade)

[Facade sourcemaking.com](https://sourcemaking.com/design_patterns/facade)

- ## Composite 	

`Pattern Composite` позволяет объединять объекты в древовидную структуру и работать с ней, как если бы это был отдельный объект.
Замечательной особенностью `Pattern Composite` является возможность рекурсивного запуска методов по всей древовидной структуре и суммирования результатов.
Позволяя одинаково трактовать индивидуальные и составные объекты.

Использование `Pattern Composite` имеет смысл только в том случае, если базовую модель вашего приложения можно представить в виде дерева.
Решает проблему легкого доступа/обхода составных элементов

Пример:

Давайте попробуем понять шаблон Composite на примере файловой системы операционной системы. 
В файловой системе существует два типа объектов: файлы и папки. Бывают случаи, когда с файлами и папками следует обращаться одинаково. 
Вот тут-то и пригодится шаблон Composite.
Fileи Directoryоба trait Componentимеют один searchметод. 
Для файла он просто просмотрит содержимое файла; для папки он просмотрит все файлы этой папки, чтобы найти это ключевое слово.

![Composite](https://github.com/Jekahome/Patterns/blob/main/_img/Composite.png "Composite")

[Composite refactoring.guru](https://refactoring.guru/design-patterns/composite)

- ## Proxy	

`Pattern Proxy` позволяет подставлять вместо реальных объектов специальные объекты-заменители. 
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Применение:

1.Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

2.Удаленный прокси-сервер предоставляет локального представителя объекта, который находится в другом адресном пространстве. 
Это то, что обеспечивает код-заглушка в RPC и CORBA.

3.Защитный прокси-сервер контролирует доступ к конфиденциальному главному объекту.
Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).
Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

4.Умный прокси выполняет дополнительные действия при доступе к объекту. Типичное использование включает в себя:
Подсчет количества ссылок на реальный объект, чтобы его можно было автоматически освободить, когда ссылок больше нет (так называемый умный указатель),
Загрузка постоянного объекта в память при первом обращении к нему,
Проверка блокировки реального объекта перед доступом к нему, чтобы гарантировать, что никакой другой объект не сможет его изменить.

Эмпирические правила

`Pattern Decorator` и `Pattern Proxy` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. 
Паттерны отличаются тем, что `Pattern Proxy` сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.

[Proxy refactoring.guru](https://refactoring.guru/ru/design-patterns/proxy/rust/example)

- ## Private Class Data	

Ограниченный доступ к средствам доступа / мутаторам.

- ## Flyweight	

`Pattern Flyweight` (Приспособленец, Кэш, Легковес) позволяет вместить бóльшее количество объектов в отведённую оперативную память.
`Pattern Flyweight` экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.
`Pattern Flyweight` позволяет экономить память, кешируя одинаковые данные, используемые в разных объектах.
`Pattern Flyweight` - это шаблон, который помогает минимизировать использование памяти за счет совместного использования и повторного использования данных.

Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные — это «внешнее состояние».
`Pattern Flyweight` предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.

**Структура**

Вы всегда должны помнить о том, что Легковес применяется в программе, имеющей громадное количество одинаковых объектов.
Этих объектов должно быть так много, чтобы они не помещались в доступную оперативную память без ухищрений.
Паттерн разделяет данные этих объектов на две части — легковесы и контексты.

`Pattern Flyweight` содержит состояние, которое повторялось во множестве первоначальных объектов.
Один и тот же легковес можно использовать в связке со множеством контекстов.
Состояние, которое хранится здесь, называется внутренним, а то, которое он получает извне — внешним.

Контекст содержит «внешнюю» часть состояния, уникальную для каждого объекта. Контекст связан с одним из объектов-легковесов, хранящих оставшееся состояние.

Поведение оригинального объекта чаще всего оставляют в Легковесе, передавая значения контекста через параметры методов.
Тем не менее, поведение можно поместить и в контекст, используя легковес как объект данных.

Клиент вычисляет или хранит контекст, то есть внешнее состояние легковесов.
Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

Фабрика легковесов управляет созданием и повторным использованием легковесов. Фабрика получает запросы, в которых указано желаемое состояние легковеса.
Если легковес с таким состоянием уже создан, фабрика сразу его возвращает, а если нет — создаёт новый объект.

**Эмпирические правила**

`Pattern Composite` часто совмещают с `Pattern Flyweight`, чтобы реализовать общие ветки дерева и сэкономить при этом память.

`Pattern Flyweight` объясняет, когда и как можно совместно использовать объекты `Pattern State`.

[Flyweight refactoring.guru](https://refactoring.guru/ru/design-patterns/flyweight)

## <ins>Паттерны поведения</ins>

Эта группа паттернов позволяет структурировать подходы к обработке поведения и взаимодействия объектов. Проще говоря, как должны проходить процессы в которых существует несколько вариантов протекания событий.

- ## Command	

`Pattern Command` — это поведенческий паттерн проектирования, который превращает запросы в объекты, 
позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, 
а также поддерживать отмену операций.

Когда использовать паттерн команды:

- Очередь. Когда запросы необходимо обрабатывать в определенные моменты времени и в соответствии с различными триггерными ситуациями.

- Слои. Когда необходимо разделить клиента и поставщика услуг (инкапсуляция получателя, для вызывающего не важно какая команда будет послана)

- Когда возникает необходимость в функции отката для определенных операций

- Когда необходима история запросов

- Когда есть необходимость добавить новые команды

- При необходимости параметризации объектов по действию

Мы хотим, чтобы эти действия или команды выполнялись или вызывались в определенном порядке позже и в другое время. 
Эти команды также могут быть вызваны в результате какого-либо события. 
Например, когда пользователь нажимает кнопку или при получении пакета данных. 
Кроме того, эти команды могут быть отменены. 
Это может оказаться полезным для работы редактора. 
Возможно, нам захочется хранить журналы выполненных команд, чтобы можно было повторно применить изменения позже, если система выйдет из строя.

[Command refactoring.guru](https://refactoring.guru/ru/design-patterns/command)

[Command rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html)

- ## Command + Composite	

Компоновка команд в блоки

- ## Command + Composite + Chain Of Responsibilities

Компоновка команд в блоки и делегирование другим командам

- ## Interpreter	

Известен как Little (Small) Language, позволяет создать **свой язык** для гибкости и простоты использования пользователем

Design components:

Abstract Expression - объявляет операцию interpret(), которую переопределяют все узлы (терминальные и нетерминальные) в AST.
    класс абстрактного выражения определяет абстрактный интерфейс для языковых выражений. Он объявляет interpret()
    метод, определяющий логику интерпретации выражений.

Terminal Expression - (NumberExpression): реализует операцию interpret() для терминальных выражений.
    классы терминальных выражений представляют собой элементарные строительные блоки языка. Они реализуют интерфейс
    абстрактных выражений и обеспечивают логику интерпретации терминальных выражений.

Non-Terminal Expression - (AdditionExpression, SubtractionExpression, and MultiplicationExpression):
    реализует операцию interpret() для всех нетерминальных выражений.
    классы нетерминальных выражений представляют собой составные выражения, состоящие из нескольких подвыражений.
    Они также реализуют интерфейс абстрактных выражений и обеспечивают логику интерпретации составных выражений.

Context - содержит информацию, которая является глобальной для интерпретатора.
    класс контекста предоставляет любую необходимую информацию или состояние, необходимое для интерпретации выражений.
    Он сохраняет глобальную информацию, разделяемую между выражениями во время интерпретации.

Client - (ExpressionParser): строит (или предоставляет) AST, собранный из TerminalExpression и NonTerminalExpression.
    Клиент вызывает операцию interpret()

![Interpreter](https://github.com/Jekahome/Patterns/blob/main/_img/Interpreter.png "Interpreter")

[Interpreter sourcemaking.com](https://sourcemaking.com/design_patterns/interpreter)

[Interpreter geeksforgeeks](https://www.geeksforgeeks.org/interpreter-design-pattern/)

[Interpreter medium.com](https://medium.com/@rajeshvelmani/understanding-language-interpretation-with-the-interpreter-design-pattern-in-java-b2a3969eaf9)

- ## Strategy	

Позволяет эффективно работать коду, благодаря наличию реализованных стратегий основываясь на входных данных.
Все стратегии реализуются по обшему интерфейсу и соответственно код становится гибким/взаимозаменяемым.
Это позволяет отказаться от использования переключателей и/или условных операторов.
К примеру выбор способа сортировки зависит от типа и размера данных, соответственно выбирая подходящий алгоритм мы используем паттерн стратегия.

Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к `Pattern Strategy`.

Одно из преимуществ использования `Pattern Strategy` заключается в том, что мы можем избавиться от ветвления `if/else`.
Достигается это за счет того, что `Client` "знает",
какой алгоритм он хочет использовать и передает объект алгоритма в конструктор класса - `Context`. 
Согласно `Singl responsibility` разделяем классы на подклассы.

Один из принципов SOLID: open/close - предполагает сущность открыта для расширения но закрыта для модификаций. Таким образом при надобности расширить
поведение сущности мы просто добавляем еще одну стратегию, вместо изменения кода сущности.

Мотивы
Программа должна обеспечивать различные варианты алгоритма или поведения
Нужно изменять поведение каждого экземпляра класса
Необходимо изменять поведение объектов на стадии выполнения
Введение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы


Эмпирические правила:

- `Pattern Strategy` похожа на `Pattern Method`, за исключением степени детализации.

- `Pattern State` похож на `Pattern Strategy`, за исключением своего намерения.

- `Pattern State, Strategy, Bridge` (и в некоторой степени `Pattern Adapter`) имеют схожие структуры решений. 
Все они разделяют элементы идиомы «handle/body». Они различаются по назначению – то есть решают разные задачи.

- `Pattern Strategy` имеет две разные реализации, первая похожа на `Pattern State`. 
Разница заключается во времени привязки (`Pattern Strategy` — это шаблон с однократной привязкой, тогда как `Pattern State` более динамичен).
Объекты стратегии часто становятся хорошими легковесами.

- `Pattern Strategy` позволяет вам изменить внутренности объекта. `Pattern Decorator` позволяет менять скин.
И `Pattern Strategy`, и `Pattern Decorator` могут применяться для изменения поведения конкретных классов. 
Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более удобным, а недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.

Состоит:

 - Strategy - абстрактная сущность 

 - ConcreteStrategy - конкретные реализации стратегии 

 - Context - содержит конкретную стратегию
 
 - Client - выбирает какую стратегию применять

[Strategy rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/strategy.html)

[Strategy sourcemaking.com](https://sourcemaking.com/design_patterns/strategy)

[Strategy refactoring.guru](https://refactoring.guru/ru/design-patterns/strategy)

[Strategy ru.wikipedia.org](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

- ## Visitor	

`Pattern Visitor` позволяет добавлять в программу новые операции, не изменяя разнородные классы объектов, 
над которыми эти операции могут выполняться.
(т.е. все струтуры или перечисления остаюся нетронутыми `...Industrial,Residential,Commercial,Build,LevelBuild`)

`Pattern Visitor` полезен везде, где вы хотите применить алгоритм к разнородным данным. 
Если данные однородны, просто применяем один метод. 
Использование объекта посетителя (а не функционального подхода) позволяет посетителю сохранять состояние и, 
таким образом, передавать информацию между узлами.

Т.е. в идеале мы бы могли имплементироваться от трейта и просто вызывая обший для всех метод решить свою задачу, но мы в силу каких-то
причин так не можем делать. 
Так-же, возможная причина, это неуместная логика в рамках этих структур или потенциальные изменения в новой требуемой логике.

`Pattern Fold` аналогичен `Pattern Visitor`, но создает новую версию посещенной структуры данных.

**Single-serving visitor** (одноразовый посетитель)

Является частным случаем использования `Pattern Visitor`. Если в случае с обычным «посетителем» у нас есть врач которого мы можем отправить к разным больным (и при желании по несколько раз), то в данном паттерне можно привести аналогию, что мы нанимаем врача, отправляем его к одному больному и после обследования сразу увольняем.

**Hierarchical visitor** (иерархический посетитель)

Тот же самый `Pattern Visitor`, однако в данном случае он отправляется к не одному больному, а в целую больницу и обходит там всех больных.

[Visitor refactoring.guru](https://refactoring.guru/ru/design-patterns/visitor)

[Visitor sourcemaking.com](https://sourcemaking.com/design_patterns/visitor)

[Visitor rust-unofficial.github.io](https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html)

[Visitor habr.com](https://habr.com/ru/articles/332042/)

- ## Observer	

`Pattern Observer` - полезен, когда вас интересует состояние объекта и вы хотите получать уведомления о любых изменениях.
Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

В `Pattern Observer` объект, который наблюдает за состоянием другого объекта, называется Observer,
а объект, за которым ведется наблюдение, называется Subject.

Определите зависимость «один ко многим» между объектами, чтобы при изменении состояния одного объекта
все его зависимые объекты автоматически уведомлялись и обновлялись.

Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.

**Проблема**

Представьте, что вы имеете два объекта: Покупатель и Магазин. В магазин вот-вот должны завезти новый товар, который интересен покупателю.
Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.
С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.
Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

**Проблема**

Большая монолитная конструкция плохо масштабируется, поскольку предъявляются новые требования к графическому отображению или мониторингу.
Вообщем легче отправить сообщение нежели добраться в сложившейся иерархии классов до конкретного обьекта.

`Pattern Observer` предлагает хранить внутри объекта издателя `Observer` список ссылок на объекты подписчиков `Subject`, 
причём издатель не должен вести список подписки самостоятельно. 
Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.
Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и 
оповещать их об этом, вызывая определённый метод объектов-подписчиков.
Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

**Pattern Blackboard** (доска объявлений)

Данный паттерн служит для обеспечения взаимодействия между большим количеством объектов. Он является расширением `Pattern Observer` и позволяет централизованно обслуживать как «наблюдателей», так и «создателей событий». В аналогии подпиской на email уведомления, это будет сам сайт подписки, который обслуживает множество подписчиков и тех, кто для них создает информацию (сообщения).

[Observer chercher.tech](https://chercher.tech/rust/observer-design-pattern-rust)

[Observer refactoring.guru](https://refactoring.guru/ru/design-patterns/observer)

- ## Delegation	 

Объект, вместо того чтобы выполнять одну из своих поставленных задач, поручает её связанному вспомогательному объекту.

[Delegation](https://snoekiede.medium.com/easy-delegation-in-rust-the-delegation-pattern-hacking-with-rust-9366f10bf7f2?source=user_profile---------19----------------------------)

- ## Iterator	

`Pattern Iteratot` - Предоставьте способ последовательного доступа к элементам агрегатного объекта, не раскрывая его базовое представление.

Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой. 
Это может быть ограничение доступа, сортировка или любая другая операция над множеством объектов.

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.

**Аналогия**

Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. 
Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.
Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции. 
Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.

**Проблема**

Также, возможный способ применения, когда вы используете экзотическую коллекцию данных т.е. не тривиально организованные данные.
Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину,
 но завтра потребуется возможность перемещаться по дереву в ширину.
Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, которая заключается в эффективном хранении данных. 
Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.

**Проблема**

Необходимо «абстрагировать» обход совершенно разных структур данных, чтобы можно было определить алгоритмы, 
способные прозрачно взаимодействовать с каждой из них.

Агрегированный объект, такой как список, должен давать вам возможность доступа к его элементам, не раскрывая его внутреннюю структуру. 
Более того, вы можете захотеть перемещаться по списку разными способами, в зависимости от того, чего вам нужно достичь. 
Но вы, вероятно, не делаете этого. хотите раздуть интерфейс списка операциями для разных обходов, даже если вы можете предвидеть те, 
которые вам потребуются. Вам также может потребоваться иметь более одного ожидающего обхода в одном и том же списке». 
Кроме того, может оказаться полезным предоставление единого интерфейса для обхода многих типов агрегатных объектов (т. е. полиморфной итерации).

Абстракция `Iterator` является фундаментальной для новой технологии, называемой «обобщенным программированием». 
Эта стратегия стремится явно отделить понятие «алгоритм» от понятия «структура данных». 

Эмпирические правила
- Абстрактное синтаксическое дерево `Pattern Interpreter` является составным (поэтому также применимы `Pattern Iteratot` и `Pattern Visitor`).

- `Pattern Memento` часто используется вместе с `Pattern Iteratot`. Итератор может использовать Memento для фиксации состояния итерации. Итератор хранит Memento внутри себя.

В Rust итераторы ленивы, то есть они не действуют, пока вы не вызовете методы, которые используют итератор для его использования.

[Iterator sourcemaking.com](https://sourcemaking.com/design_patterns/iterator)

[Iterator refactoring.guru](https://refactoring.guru/ru/design-patterns/iterator)

[Rust std::iter](https://doc.rust-lang.org/std/iter/index.html)

- ## Mediator	

`Pattern Mediator` (посредник) позволяет уменьшить связанность множества классов между собой (многие ко многим), благодаря перемещению этих связей в один класс-посредник.
Устраняет зависимости между компонентами, позволяя повторно их использовать. Упрощает взаимодействие между компонентами. Централизует управление в одном месте.

Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник, который знает, 
кому нужно перенаправить тот или иной запрос. 
Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

Объектам больше нет нужды вызывать друг друга напрямую. 
Это хорошая альтернатива `Pattern Observer`, если у вас есть “центр интеллекта” вроде контроллера (но не в смысле MVC)
Все компоненты (называемые «Коллеги») объединяются в интерфейс MediatorInterface.
Подписчики или объединенные компоненты делегируют управление медиатору.

Таким образом, посредник скрывает в себе все сложные связи и зависимости между классами отдельных компонентов программы. 
А чем меньше связей имеют классы, тем проще их изменять, расширять и повторно использовать.

**Аналогия**

Пилоты садящихся или улетающих самолётов не общаются напрямую с другими пилотами. 
Вместо этого они связываются с диспетчером, который координирует действия нескольких самолётов одновременно. 
Без диспетчера пилотам приходилось бы все время быть начеку и следить за всеми окружающими самолётами самостоятельно, а это приводило бы к частым катастрофам в небе.
Важно понимать, что диспетчер не нужен во время всего полёта. Он задействован только в зоне аэропорта, когда нужно координировать взаимодействие многих самолётов.

**Применимость**

1. Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
Посредник позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.

2. Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
После применения паттерна компоненты теряют прежние связи с другими компонентами, а всё их общение происходит косвенно, через объект-посредник.

3.Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.
Если раньше изменение отношений в одном компоненте могли повлечь за собой лавину изменений во всех остальных компонентах, 
то теперь вам достаточно создать подкласс посредника и поменять в нём связи между компонентами.

**Эмпирические правила**

Разница между `Pattern Mediator` и `Pattern Observer` не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.

Цель `Pattern Mediator` — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. 
С другой стороны, цель `Pattern Observer` — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

![Mediator](https://github.com/Jekahome/Patterns/blob/main/_img/Mediator.png "Mediator")

![Mediator](https://github.com/Jekahome/Patterns/blob/main/_img/Mediator2.png "Mediator")

[Mediator refactoring.guru](https://refactoring.guru/ru/design-patterns/mediator)

[Mediator github.com/fadeevab](https://github.com/fadeevab/mediator-pattern-rust/blob/main/README.md)

- ## State	

В зависимости от состояния изменяется поведение

`Pattern State` невозможно рассматривать в отрыве от концепции машины состояний, также известной как стейт-машина или конечный автомат
Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. 
Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях, 
программа может по-разному реагировать на одни и те же события, которые происходят с ней.

`Pattern State` — это решение проблемы того, как заставить поведение зависеть от состояния.

**Аналогия**

Паттерн State позволяет объекту изменять свое поведение при изменении его внутреннего состояния. 
Эту картину можно наблюдать в торговом автомате. 
У торговых автоматов есть состояния, основанные на инвентаре, сумме внесенной валюты, возможности внесения сдачи, выбранном товаре и т. д. 
Когда валюта внесена и сделан выбор, торговый автомат либо доставит продукт без сдачи, либо доставит товар. 
продукт и изменить его, не доставить продукт из-за недостаточности валюты на депозите или не доставить продукт из-за истощения запасов.

**Проблема**

Машину состояний чаще всего реализуют с помощью множества условных операторов, `if` либо `switch`, 
которые проверяют текущее состояние объекта и выполняют соответствующее поведение. 
Основная проблема такой машины состояний проявится в том случае, если в обьект добавить ещё десяток состояний. 
Каждый метод будет состоять из увесистого условного оператора, перебирающего доступные состояния. Такой код крайне сложно поддерживать. 
Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, которые содержат условные операторы машины состояний.
Путаница и нагромождение условий особенно сильно проявляется в старых проектах. 
Набор возможных состояний бывает трудно предопределить заранее, поэтому они всё время добавляются в процессе эволюции программы. 
Из-за этого решение, которое выглядело простым и эффективным в самом начале разработки, может впоследствии стать проекцией большого макаронного монстра.
`Pattern State` предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, 
а затем вынести туда поведения, соответствующие этим состояниям.

**Эмпирические правила**

Реализация `Pattern State` основана на шаблоне `Pattern Strategy`. Разница между `Pattern State` и `Pattern Strategy` заключается в намерении. 
При использовании Strategy выбор алгоритма достаточно стабилен. При использовании State изменение состояния объекта «контекст» приводит к 
выбору объектов стратегии из «палитры».

Flyweight объясняет, когда и как можно совместно использовать объекты State.

[State examples](https://github.com/Jekahome/Patterns/tree/main/src/idioms/1.Type_safety/1.2.Typestates)

[State sourcemaking.com](https://sourcemaking.com/design_patterns/state)

[State refactoring.guru](https://refactoring.guru/ru/design-patterns/state)

- ## Specification	 

Строит правила на соответствие которых проверяются объекты

Спецификация (Specification)
   Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. 
   Композитный класс спецификация имеет один метод, называемый isSatisfiedBy, 
   который возвращает истину или ложь в зависимости от того, удовлетворяет ли данный объект спецификации.

- ## Memento (Хранитель)	

`Pattern Memento` (`Token`) позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.
По мере разработки вашего приложения вы можете захотеть сохранить контрольные точки в своем приложении и позже вернуться к этим контрольным точкам.
Предоставить возможность выполнить действие отмены, чтобы восстановить объект в предыдущее состояние.

**Аналония**

Отмена действия, возврат назад или сочетание клавиш Ctrl+Z — одна из наиболее часто используемых операций в редакторе. 
Для реализации операции отмены используется `Pattern Memento`. Это делается путем сохранения текущего состояния объекта по мере его изменения.

Одним из важных моментов, которые следует избегать при реализации `Pattern Memento`, является то, что инкапсуляция объекта не должна подвергаться риску.
Паттерн Снимок поручает создание копии состояния объекта самому объекту.
Паттерн предлагает держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом, позволяющим, например, узнать дату изготовления или название снимка. 
Но, с другой стороны, снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние.
Такая схема позволяет создателям производить снимки и отдавать их для хранения другим объектам, называемым опекунами. 
Опекунам будет доступен только ограниченный интерфейс снимка, поэтому они никак не смогут повлиять на «внутренности» самого снимка. 
В нужный момент опекун может попросить создателя восстановить своё состояние, передав ему соответствующий снимок.

В некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка.

**Эмпирические правила**

`Pattern Command` и `Pattern Memento` можно использовать сообща для реализации отмены операций. 
В этом случае объекты команд будут отвечать за выполнение действия над объектом, а снимки будут хранить резервную копию состояния этого объекта, 
сделанную перед самым запуском команды.

`Pattern Memento` иногда можно заменить Прототипом, если объект, состояние которого требуется сохранять в истории, довольно простой, 
не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.

**Участники:**

1. Originator (Создатель) может производить снимки своего состояния, а также воспроизводить прошлое состояние, если подать в него готовый снимок.

2. Memento (Снимок) — это простой объект данных, содержащий состояние создателя. Надёжнее всего сделать объекты снимков неизменяемыми, передавая в них состояние только через конструктор.

3. Caretaker (Смотритель/Опекун/Хранитель) должен знать, когда делать снимок создателя и когда его нужно восстанавливать.
  Опекун может хранить историю прошлых состояний создателя в виде стека из снимков. 
  Когда понадобится отменить выполненную операцию, он возьмёт «верхний» снимок из стека и передаст его создателю для восстановления.
 

![Memento](https://github.com/Jekahome/Patterns/blob/main/_img/Memento.png "Memento")

[Memento refactoring.guru](https://refactoring.guru/ru/design-patterns/memento)

[Memento chercher.tech](https://chercher.tech/rust/momento-design-pattern-rust)

- ## Chain Of Responsibilities 

`Pattern Chain Of Responsibilities` используется для достижения слабой связи отправителя запроса с получателем. Делегировать задачу следующему. 

Позволяет передавать запросы последовательно по цепочке обработчиков. 
Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
Механизм цепочки использует рекурсивную композицию, позволяющую связывать неограниченное количество обработчиков.

`Pattern Chain Of Responsibilities` позволяет избежать связывания отправителя запроса с получателем, предоставляя более чем одному объекту возможность обработать запрос.

По сути это набор обработчиков, которые по очереди получают запрос, а затем решают обрабатывать его или нет. 
Если запрос не обработан, то он передается дальше по цепочке. 
Если же он обработан, то паттерн сам решает передавать его дальше или нет.
middleware

Необходимость эффективной обработки запросов без жесткого связывания отношений и приоритета обработчиков или сопоставлений запросов с обработчиками.

Паттерн предлагает связать объекты обработчиков в одну цепь. 
Каждый из них будет иметь ссылку на следующий обработчик в цепи. 
Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Не используйте `Pattern Chain Of Responsibilities`, если каждый запрос обрабатывается только одним обработчиком или когда клиентский объект знает, 
какой объект службы должен обрабатывать запрос.


**Применимость**

1. Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
   С помощью `Pattern Chain Of Responsibilities` вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

2. Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
   `Pattern Chain Of Responsibilities` позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

3. Когда набор объектов, способных обработать запрос, должен задаваться динамически.
   В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

4. Объектно-ориентированный связанный список с рекурсивным обходом.

**Аналогия**

Банкоматы используют цепочку ответственности в механизме выдачи денег.
Для сдачи подойдут все купюры из которых возможно составить сумму и они есть в наличии.

Эмпирические правила

`Pattern Chain Of Responsibilities` часто используют вместе с Компоновщиком. В этом случае запрос передаётся от дочерних компонентов к их родителям.

Обработчики в `Pattern Chain Of Responsibilities` могут быть выполнены в виде `Pattern Command`. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.
Но есть и другой подход, в котором сам запрос является  `Pattern Command`, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.

`Pattern Chain Of Responsibilities` и `Pattern Decorator` имеют очень похожие структуры. 
Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но `Pattern Decorator` не прерывает ход выполнения.

![Сhain-of-responsibility](https://github.com/Jekahome/Patterns/blob/main/_img/chain-of-responsibility.png "Сhain-of-responsibility")

[Chain Of Responsibilities refactoring.guru](https://refactoring.guru/ru/design-patterns/chain-of-responsibility/rust/example)

[Chain Of Responsibilities chercher.tech](https://chercher.tech/rust/chain-of-responsibility-design-pattern-rust)

- ## Template method	

`Template method` - определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. 
Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
Идея состоит в том, чтобы позволить наследникам абстрактного
шаблона переопределить поведение алгоритмов родителя.
  
Это простой способ изолировать логику в конкретные классы и уменьшить копипаст,
поэтому вы повсеместно встретите его в том или ином виде.

`Template method` предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и 
вызывать их в одном шаблонном методе друг за другом.

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и 
остальные шаги, которые для этого подкласса не так важны.

[Template method refactoring.guru](https://refactoring.guru/ru/design-patterns/template-method)

- ## Command invoker	 

Command и receiver исполнитель назначение команды и выполнение ее исполнителем

-- ---------------------------------


- ## DataMaper	

Посредник между постоянным хранилищем и данными в памяти( массив)
Цель паттерна в том,чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных.
В отличии от ActiveRecord где полностью отображается структура реаляционной базы на свойства классов
В связке с паттреном Repository который представляет слой над DataMaper получаем независимую друг от друга систему общения бизнес-логики с данными

Персистентность (т.е. минимизация подверженности изменениям ) архитектурного слоя поддрживает Repository за счет того что он берет на себя все изменения/новые требования бизнес-правил
 и в итоге обьекты DataMapers остаются неизменны

- ## ActiveRecord	

Схема Active Record — это подход к доступу к данным в базе данных. Таблица базы данных или представление обёрнуты в классы. 
Таким образом, объектный экземпляр привязан к единственной строке в таблице. После создания объекта новая строка будет добавляться к таблице на сохранение. 
Любой загруженный объект получает свою информацию от базы данных. Когда объект обновлён, соответствующая строка в таблице также будет обновлена. 
Класс обёртки реализует методы средства доступа или свойства для каждого столбца в таблице или представлении.
Нарушает принцип единственной ответственности (SRP) или нет ?

- ## Dependency injection (DI)

Для реализации слабосвязанной архитектуры. 
Для выноса из класса неявных зависимостей тремя способами(путем явной зависимости через конструктор,метод,интерфейс) для явной зависимости что бы была возможность подменить обьекты при тестировании.
Объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму
Чтобы получить более тестируемый, сопровождаемый и расширяемый код.
Реализуется через передачу обьекта в конструктор,метод,интерфейс

Внедрение зависимости позволяет переложить часть ответственности за какой-то функционал на другие объекты. 
Например если нам требуется нанять новый персонал, то мы можем не создавать свой отдел кадров, а внедрить зависимость от компании по подбору персонала, которая свою очередь по первому нашему требованию «нам нужен человек», будет либо сама работать как отдел кадров, либо же найдет другую компанию (при помощи «локатора служб»), которая предоставит данные услуги.
«Внедрение зависимости» позволяет перекладывать и взаимозаменять отдельные части компании без потери общей функциональности.

- ## Service Locator	

Для реализации слабосвязанной архитектуры, чтобы получить хорошо тестируемый, сопровождаемый и расширяемый код. 
Паттерн Инъекция зависимостей (DI) и паттерн Локатор Служб — это реализация паттерна Инверсия управления (Inversion of Control, IoC)
Анти-паттерн так как нарушает принцип SOLID инверсии зависимости т.е. он избавляет другие классы от этого но сам зависим от конкретных классов.
В случае изменения данных зависимостей мы рискуем сломать функционал классов, которые их используют, вследствие чего затрудняется поддержка системы.

- ## Row Data Gateway (DataMaper) 

Предоставляет вам объекты, которые выглядят точно так же, как записи в вашей структуре записей, но доступны с помощью обычных механизмов вашего языка программирования. Все детали доступа к источникам данных скрыты за этим интерфейсом.

- ## Specification

[Specification](https://snoekiede.medium.com/simplified-precision-unraveling-the-simple-specification-pattern-in-rust-for-expressive-code-b2096deffbc7?source=user_profile---------5----------------------------)

# Архитектура программного обеспечения, ориентированная на шаблоны

[PoSA](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)


# Шаблоны баз данных

Шаблоны баз данных, сохранять и извлекать данные из баз данных и устанавливать соответствие между объектами базы данных и приложения.

- ## Data Mapper 	

Преобразователь Данных — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже загружено и используется для логической обработки). 
Цель паттерна в том, чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных. 
Слой состоит из одного или более mapper-а (или объектов доступа к данным), отвечающих за передачу данных. 
Реализации mapper-ов различаются по назначению. 
Общие mapper-ы могут обрабатывать всевозоможные типы сущностей доменов, а выделенные mapper-ы будет обрабатывать один или несколько конкретных типов.

- ## Identity Map	

Обеспечивает однократную загрузку объекта, сохраняя данные об объекте в карте соответствия. 
При обращении к объектам, ищет их в карте соответсвия.
Паттерн Identity Map (Карта присутствия / Карта соответствия) хранит записи о всех объектах, которые были считаны из БД за время выполнения одного действия. 
Когда происходит обращение к объекту, проверяется карта соответствия (присутствия), чтобы узнать, загружен ли объект.

- ##  Lazy Load 

Загрузка данных по мере необходимости


[Rust patterns](https://rust-unofficial.github.io/patterns/)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

------------------------------------------------------------------

## [Паттерны проектирования](http://design-pattern.ru/patterns/) 

## Базовые паттерны
    Mapper (Распределитель)
    Money (Деньги)
    Special Case (Особый Случай)
    Plugin (Плагин)
    Gateway (Шлюз)
    Separated Interface (Выделенный интерфейс)
    Registry (Реестр)
    Service Stub (Сервисная заглушка)
    Value Object (Объект-значение)
    Record Set ()
    Layer Supertype (Супертип Уровня)

## Паттерны веб-представления
    Transform View (Преобразователь)
    Template View (Шаблонизатор)
    Application Controller (Контроллер приложения)
    Two Step View (Двухшаговая шаблонизация)
    Page Controller (Контроллер страницы)
    Front Controller (Контроллер входа / Единая точка входа)
    MVC - Model View Controller (Модель-Вид-Контроллер)

## Паттерны архитектуры источников данных
    Row Data Gateway (Шлюз к данным записи)
    Active Record (Активная запись)
    Table Data Gateway (Шлюз к данным таблицы)
    Data Mapper ()
    Паттерны Объектно-Реляционной логики
    Lazy Load (Ленивая загрузка)
    Identity Map (Карта присутствия / Карта соответствия)
    Unit of Work (Единица работы)

## Паттерны Объектно-Реляционного структурирования
    Identity Field (Поле первичного ключа)
    Foreign Key Mapping (Разметка внешних ключей)
    Association Table Mapping (Разметка таблиц связей)
    Dependent Mapping (Управление распределением подчинённых сущностей)
    Embedded Value (Объединённое свойство)
    Serialized LOB (Сериализованный LOB)
    Single Table Inheritance (Наследование с единой таблицей)
    Class Table Inheritance (Наследование с таблицами классов)
    Concrete Table Inheritance (Наследование с таблицами конечных классов)
    Inherritance Mappers (Наследуемые распределители)

## Паттерны логики сущности
    Transaction Script (Сценнарий транзакции)
    Domain Model (Модель области определения)
    Table Module (Обработчик таблицы)
    Service Layer (Сервисный уровень)

## Паттерны обработки Объектно-Реляционных метаданных
    Metadata Mapping (Распределение на основе метаданных)
    Query Object (Объект-запрос)
    Repository (Репозиторий)

## Паттерны распределения данных
    Remote Facade (Парадный вход)
    Data Transfer Object (Объект передачи данных)

## Паттерны локальной конкуренции
    Optimistic Offline Lock (Оптимистичная блокировка)
    Pessimistic Offline Lock (Пессимистичная блокировка)
    Coarse Grained Lock (Грубая блокировка)
    Implicit Lock (Скрытая блокировка)

------------------------------------------------------------------
## Слоеная архитектура 

...

## Принципы DDD 

...


### CQRS-ES

Разделение команд-запросов (CQS) «Функции не должны вызывать абстрактные побочные эффекты... только команды (процедуры) могут вызывать побочные эффекты». - Бертран Мейер: Объектно-ориентированное создание программного обеспечения

CQRS — это стиль архитектуры, в котором операции чтения отделены от операций записи. Использовал с паттерном command
 Подход сформулировал Грег Янг на основе принципа CQS, предложенного Бертраном Мейером. 
Чаще всего (но не всегда) CQRS реализуется в ограниченных контекстах (bounded context) приложений, проектируемых на основе DDD.
 Одна из естественных причин развития CQRS — не симметричное распределение нагрузки и сложности бизнес-логики на read и write — подсистемы Большинство бизнес-правил и сложных проверок находится во write — подсистеме. 

--------------
 
[Rust Design Patterns](https://rust-unofficial.github.io/patterns/)

[Rust Design Patterns rust-unofficial](https://github.com/rust-unofficial/patterns)

[Rust Design Patterns refactoring.guru](https://refactoring.guru/ru/design-patterns/rust)

### ООП паттерны

[Rust Design Patterns](https://chercher.tech/rust/observer-design-pattern-rust)

[Паттерны проектирования](http://design-pattern.ru/patterns/)

[Каталог шаблонов архитектуры корпоративных приложений](https://martinfowler.com/eaaCatalog/index.html)

[Паттерны ООП в метафорах](https://habr.com/ru/articles/136766/)

[Что такое анти-паттерны?](https://habr.com/ru/articles/59005/)


### DesignPatternsPHP

[DesignPatternsPHP 1](https://designpatternsphp.readthedocs.io/ru/latest/index.html)

[DesignPatternsPHP github](https://github.com/domnikl/DesignPatternsPHP)

[DesignPatternsPHP 2](https://dron.by/)

[«Паттерны» функционального программирования](https://habr.com/ru/articles/337880/)

```bash
Куда складывать:
- Google Диск Exel Manual/Rust(Patterns/Algorithms)
- Google Диск Exel Manual/Patterns
- GitHub Jekahome/Pattrens

Источники:
- книги ../DesignPatterns_AndriyBuday
- книги ../Design-Patterns.md
- книги ../Разработка интерфейсов.паттерны проектирования.Дженифер Тидвелл
- книги ../Head_First_Паттерны_проектирования_2022_Эрик_Фримен,_Элизабет_Робсон
- код ../Patterns_Others_lang
- код ../Patterns_Rust_PHP_TypeScript
```
